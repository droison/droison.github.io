<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[野火🔥]]></title>
  <link href="http://www.chaisong.xyz/atom.xml" rel="self"/>
  <link href="http://www.chaisong.xyz/"/>
  <updated>2018-09-26T13:26:48+08:00</updated>
  <id>http://www.chaisong.xyz/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.coderforart.com/">CoderForArt</generator>

  
  <entry>
    <title type="html"><![CDATA[【从历年weak看iOS面试】]]></title>
    <link href="http://www.chaisong.xyz/15379393489219.html"/>
    <updated>2018-09-26T13:22:28+08:00</updated>
    <id>http://www.chaisong.xyz/15379393489219.html</id>
    <content type="html"><![CDATA[
<ul>
<li><p>2013年<br/>
面试官：代理用weak还是strong?<br/>
我 ：weak 。<br/>
面试官：明天来上班吧</p></li>
<li><p>2014年<br/>
面试官：代理为什么用weak不用strong?<br/>
我 ： 用strong会造成循环引用。<br/>
面试官：明天来上班吧</p></li>
<li><p>2015年<br/>
面试官：weak是怎么实现的？<br/>
我 ：weak其实是 系统通过一个hash表来实现对象的弱引用<br/>
面试官：明天来上班吧</p></li>
<li><p>2016年<br/>
面试官：weak是怎么实现的？<br/>
我 ：runtime维护了一个weak表，用于存储指向某个对象的所有weak指针。weak表其实是一个hash（哈希）表，key是所指对象的地址，Value是weak指针的地址（这个地址的值是所指对象指针的地址）数组。<br/>
面试官：明天来上班吧</p></li>
<li><p>2017年<br/>
面试官：weak是怎么实现的？<br/>
我 ： 1 初始化时：runtime会调用objc_initWeak函数，初始化一个新的weak指针指向对象的地址。<br/>
2    添加引用时：objc_initWeak函数会调用 storeWeak() 函数， storeWeak() 的作用是更新指针指向，创建对应的弱引用表。<br/>
3    释放时,调用clearDeallocating函数。clearDeallocating函数首先根据对象地址获取所有weak指针地址的数组，然后遍历这个数组把其中的数据设为nil，最后把这个entry从weak表中删除，最后清理对象的记录。<br/>
面试官：明天来上班吧</p></li>
<li><p>2018年<br/>
面试官：weak是怎么实现的？<br/>
我 ：跟2017年说的一样，还详细补充了objc_initWeak, storeWeak, clearDeallocating的实现细节。<br/>
面试官：小伙子基础不错。13k ,996干不干？干就明天来上班。。   下一个</p></li>
<li><p>2019年<br/>
面试官：weak是怎么实现的？<br/>
我 ：     别说了，拿纸来，我动手实现一个。<br/>
面试官：等写完后，面试官慢悠悠的说，小伙子不错，我考虑考虑，你先回去吧</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[面试常见：iOS Category]]></title>
    <link href="http://www.chaisong.xyz/15378876730248.html"/>
    <updated>2018-09-25T23:01:13+08:00</updated>
    <id>http://www.chaisong.xyz/15378876730248.html</id>
    <content type="html"><![CDATA[
<hr/>

<blockquote>
<p>面试非常多候选人，涉及到runtime相关知识Category是一个常见考察点，毕竟这是应用最多的runtime场景。<br/>
本文会针对这部分知识问题做一下分解。</p>
</blockquote>

<span id="more"></span><!-- more -->

<p>1、为什么OC可以用Category给系统类加方法？</p>

<p>2、能不能给系统类加实例？</p>

<p>3、通过objc_setAssociatedObject添加的变量和正常命名的有什么区别？</p>

<p>4、和系统方法同名会怎么发生什么？</p>

<p>5、两个Category同名会怎么样？</p>

<p>6、我一定要调用其中一个被覆盖的Category方法怎么做？</p>

<p>7、+load是怎么做到所有的category的+load都调用的？</p>

<p>8、针对Category同名问题怎么解决？</p>

<p>参考</p>

<p><a href="https://developer.apple.com/library/ios/qa/qa1908/_index.html#//apple_ref/doc/uid/DTS40016829">https://developer.apple.com/library/ios/qa/qa1908/_index.html#//apple_ref/doc/uid/DTS40016829</a></p>

<p>You can use the OBJC_PRINT_REPLACED_METHODS environment variable to enable extra debug logging that prints a message when methods are replaced by category implementations. When a category is loaded, a message similar to Listing 2 is printed for each method in the category that clashes with an existing method in the original class.</p>

<p>可以设置OBJC_PRINT_REPLACED_METHODS 环境变量来开启debug日志，开启后将会打印出某一方法何时被category实现方法替代了。当category被加载完成后，一条类似清单2展示的消息会被打印出来，这条消息表明了category中的哪一个方法与原始类中的方法名产生了冲突。</p>

<p>Listing 2  Log output when a method is replaced by a category implementation</p>

<p>objc[21184]: REPLACED: -[UIView isOccludedByView:] by category MyCategory (IMP was 0x1873728a0 (/System/Library/Frameworks<br/>
/UIKit.framework/UIKit), now 0x10002e700 (/var/mobile/Containers/Bundle/Application/14AFE8C4-EA96-4A51-8D40-F1DAD35CC3D8/<YourApplicationName>.app/<YourApplicationName>)</p>

<p>Important: You should ignore log messages that do not explicitly name your application or a custom framework it links against. Some system frameworks use categories to provide implementations of methods that are defined as stubs in the original class. This causes extra log messages to be emitted when running with the OBJC_PRINT_REPLACED_METHODS environment variable enabled and is expected behavior.<br/>
重要提示：你应该忽略那些和你的程序、自定义框架无关的消息。一些系统库使用category来实现原始类中定义的某些方法。当设置OBJC_PRINT_REPLACED_METHODS环境变量为真得时候，请忽略因为上述原因产生的多余日志，因为这是正常行为</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[-[UIImage imageNamed:]方法导致的卡顿优化]]></title>
    <link href="http://www.chaisong.xyz/15378876732043.html"/>
    <updated>2018-09-25T23:01:13+08:00</updated>
    <id>http://www.chaisong.xyz/15378876732043.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">引子</h3>

<p>这两天追查app卡顿问题，打开time profiler查看方法耗时，惊奇发现<code>-[UIImage imageNamed:]</code>占用CPU时间很长：</p>

<p>下图是重复打开一个feed页面的CPU占用，发现20%的CPU时间在<code>-[UIImage imageNamed:]</code>中，显然不合理，因为我们知道<code>-[UIImage imageNamed:]</code>相对于<code>-[UIImage imageWithContentsOfFile:]</code>存在图片缓存，重复打开本地图片应该性能影响非常小。</p>

<p><img src="https://lh3.googleusercontent.com/-oDATs6Fc0-k/Wuv5XJRmS9I/AAAAAAAAHQE/vqE-ztABSbs1dbBO53gmD2deAFMqK_aeQCHMYCw/I/15254142315308.jpg" alt=""/></p>

<p>关掉time profiler的Hide System Libraries勾选项，查看系统方法堆栈和对应的耗时：</p>

<p><img src="https://lh3.googleusercontent.com/-jmeXkroBTu0/Wuv5Z1a_vLI/AAAAAAAAHQI/RU1qDJGe0e8sNexcSTpcMhnF7hUg7_XPQCHMYCw/I/15254142400149.jpg" alt=""/></p>

<p>发现<code>-[NSFileManager fileExistsAtPath:]</code>为主要耗时方法，该方法没有本地数据读取，只是判断是否存在，感觉一脸懵逼？难道内存缓存了还会每次线判一次本地存在？苹果的实现不会这么蠢吧？..</p>

<h3 id="toc_1">-[UIImage imageNamed:] 的实现原理</h3>

<p>imageNamed:实际上调用的是一个叫做UIAssetManager的类，每个Bundle有一个UIAssetManager。它有一个strong-strong的NSMapTable<NSString, UIImageAsset>的属性，用来做缓存。。。</p>

<p>如果查询不到缓存，首先命中的是Assets.car，这个是CoreUIFrramework处理的（私有framework），会解压（有缓存）那个Assets.car然后解码取回图。</p>

<p>如果还找不到，会通过Bundle的path按照那个文档描述的，搜索@3x @2x @1x .png忽略等规则，直到找到一个那种非Assets.car的bundle图，然后加载。</p>

<p>如果你的图片不在Assets.car里面，会直接触发到最远的第三部，可能遍历搜索fileExist比较耗时吧</p>

<h3 id="toc_2">最终卡顿原因</h3>

<p>原因找到了：<br/>
themedImageNamed: 方法会每次都给 imageName 加上后缀先去取图，这个应该是iOS7之前没有Images Assets之前的适配逻辑。现在其实包里面没有-667h、-736h这样的图了，会导致所有图片第一次都取不到。就会发现频繁调用fileExistsAtPath:，而没调取图逻辑。<br/>
系统缓存了所有找到图片的UIImage，没缓存找不到的黑名单。</p>

<h3 id="toc_3">一些结论和启示</h3>

<p>-[UIImage imageNamed:] 需要hook加保护<br/>
FPS优化一定要找到瓶颈，别贸然优化 --&gt; 合理使用工具<br/>
IO操作很恐怖，哪怕只是很轻量级的处理<br/>
有必要监控一下NSFileManager的IO操作情况</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[复杂多人项目Owner思考]]></title>
    <link href="http://www.chaisong.xyz/15378876732077.html"/>
    <updated>2018-09-25T23:01:13+08:00</updated>
    <id>http://www.chaisong.xyz/15378876732077.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">1、背景</h2>

<p>UGC方向业务场景比较复杂，易同时出现多职能线和多业务线的大需求，而PM经常要求赶在某个版本前上线，使得频繁出现<strong>“时间倒排”</strong>。<br/>
当业务复杂遇上需求较大，那么每个业务方人员平均参与人数将大于1人，项目复杂度也会成倍提升。<br/>
需求完成情况最终体现在“代码合入”时间节点上，分解开来，便是<strong>提测时间点</strong>和<strong>代码质量</strong>。如果开发团队没有应对复杂业务逻辑、多业务线、多人项目工程化能力，最终导致项目delay或者采用加班方式解决问题，会遭各方吐槽，长此以往，则失去信任力。 </p>

<h2 id="toc_1">2、Delay一般原因分析</h2>

<blockquote>
<p>一般出现这类原因有两点：开发者时间评估不准确；缺乏纠偏。 </p>
</blockquote>

<h3 id="toc_2">2.1 时间评估问题</h3>

<ul>
<li>需求点把握不足：没能准确的将需求各个模块分解和细化。</li>
<li>核心流程图缺失、整体架构设计缺失：整体认知不足，不能高屋建瓴。 </li>
<li>过UI/UE时间评估不足，联调时间评估不足。 </li>
</ul>

<h3 id="toc_3">2.2 Owner在项目运行中缺少纠偏</h3>

<ul>
<li>没有里程碑或者里程碑过于简略 。</li>
<li>里程碑进展出现问题，不能尽快完成纠偏，导致问题持续、放大，最终导致delay。</li>
</ul>

<h2 id="toc_4">3、规避问题方式</h2>

<h3 id="toc_5">3.1 重视技术方案设计</h3>

<ul>
<li>RD在提供排期时，需同时提供详细的分解工期，否则该排期不应予以接受。</li>
<li>Owner应review各RD的需求分解的合理性。</li>
<li>RD内部需要做技术方案，并内部进行技术方案review，技术方案需要包含核心业务流程图（后端API调用流程、主干UI交互流程）。</li>
</ul>

<h3 id="toc_6">3.2 重视站会和里程碑</h3>

<ul>
<li><strong>过UI/UE时间点</strong>和<strong>联调时间点</strong>是项目进度管理中的重要里程碑。</li>
<li>表格、看板、甘特图都是可选的项目管理工具，复杂项目运行过程中至少使用一种。</li>
<li>要有规律的站会，站会重点review进展和里程碑完成情况。</li>
<li>每次站会需根据实际情况调整<strong>分解排期</strong>和<strong>里程碑</strong>，出现delay风险需提前周知项目利益方。</li>
</ul>

<h3 id="toc_7">3.3 大需求的分解code review</h3>

<p>项目内部需有code review里程碑，根据里程碑分解code review。<br/>
--- 分阶段code review思考待续 ---</p>

<h2 id="toc_8">4、总结</h2>

<ul>
<li>RD职责：做项目拆解及各分解时间安排，做技术方案。</li>
<li>Owner职责：根据各方拆解建立排期和里程碑，并组织站会，站会中回归项目风险点。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【IGListKit】学习与分析2]]></title>
    <link href="http://www.chaisong.xyz/15378876732116.html"/>
    <updated>2018-09-25T23:01:13+08:00</updated>
    <id>http://www.chaisong.xyz/15378876732116.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>源于4月16日在小组内的分享<br/>
图床为Google相册，看不了自己准备梯子。</p>
</blockquote>

<p><img src="https://lh3.googleusercontent.com/-FqbGRx5uisM/WtrleujON-I/AAAAAAAAHH4/ZGtWfjnP6D08bAYez34nKgjvThEbB_jZQCHMYCw/I/IGList" alt="IGList学习2.001"/></p>

<p><img src="https://lh3.googleusercontent.com/-gZm3qfRkmlk/WtrkF9Zvm7I/AAAAAAAAHFc/70Ncz1Z5QwUSfJP01lW2RQ3OFSRazLUwgCHMYCw/I/IGList" alt="IGList学习2.002"/></p>

<span id="more"></span><!-- more -->

<p><img src="https://lh3.googleusercontent.com/-0pNRRLD94jg/WtrkF0NVh6I/AAAAAAAAHFk/kdL8gQco_xYgqAUdDabKvmoeQTGlBo4FgCHMYCw/I/IGList" alt="IGList学习2.003"/></p>

<p><img src="https://lh3.googleusercontent.com/-MbzRduc6H9E/WtrkF5MuexI/AAAAAAAAHFg/bv2zpQ2ocLgsVotnO59yA8WY45FSwLdMwCHMYCw/I/IGList" alt="IGList学习2.004"/></p>

<p><img src="https://lh3.googleusercontent.com/-8DxkfkXiFfU/WtrkGI1vquI/AAAAAAAAHFs/CMIbvGtYShYgfWfgjqqiWYKL9fisp5XTwCHMYCw/I/IGList" alt="IGList学习2.005"/></p>

<p><img src="https://lh3.googleusercontent.com/-YMssUFgdOTo/WtrkFwvLfdI/AAAAAAAAHFY/FvubT71TpqMi5frVQUXE-OgyCjI8G2inQCHMYCw/I/IGList" alt="IGList学习2.006"/></p>

<p><img src="https://lh3.googleusercontent.com/-ljwnSVXp7Bg/WtrlbLjmx-I/AAAAAAAAHHw/gHkL-SVc-CImh7qlBi1bjHJWeYrSz2huwCHMYCw/I/IGList" alt="IGList学习2.007"/></p>

<p><img src="https://lh3.googleusercontent.com/-3SGvodKIkfA/WtrkGIecntI/AAAAAAAAHF4/L6-ZyZ1JrM07F3AZ-dnkKnodLwpRdpdoACHMYCw/I/IGList" alt="IGList学习2.008"/></p>

<p><img src="https://lh3.googleusercontent.com/-emdHINA0rEY/WtrkGNoFWAI/AAAAAAAAHFw/JWaovg06ipk-93Z-tIUw8PavZXyVuD-PACHMYCw/I/IGList" alt="IGList学习2.009"/></p>

<p><img src="https://lh3.googleusercontent.com/-Bo3b_eh2Bls/WtrkGA1wvLI/AAAAAAAAHF0/9UQwsHt2kfUsVyfG4LXJa7h_EgLcd33PwCHMYCw/I/IGList" alt="IGList学习2.010"/></p>

<p><img src="https://lh3.googleusercontent.com/-LtkPLL-45Vs/WtrkF91FyDI/AAAAAAAAHFQ/3fU0UqYvl90JKlnOo4-r-sbLWdWjkn_LgCHMYCw/I/IGList" alt="IGList学习2.011"/></p>

<p><img src="https://lh3.googleusercontent.com/-xo9LatqnbHQ/Wtrk015UIjI/AAAAAAAAHGw/2mbSqOPTfTgaDrrd-jMKD6GroZjoZUFxgCHMYCw/I/IGList" alt="IGList学习2.012"/></p>

<p><img src="https://lh3.googleusercontent.com/-VjrOxPaermo/Wtrk05mfWZI/AAAAAAAAHG8/4sJElXUEDFwa3NevSdiuSj-ZjMQoJiGbwCHMYCw/I/IGList" alt="IGList学习2.013"/></p>

<p><img src="https://lh3.googleusercontent.com/-ShSGV8c0Lx0/Wtrk0wXv7MI/AAAAAAAAHGs/hQRPI8ySzLQdT5jJRvK1T6oSbQQEFV5JgCHMYCw/I/IGList" alt="IGList学习2.014"/></p>

<p><img src="https://lh3.googleusercontent.com/-ZWHeR9DTYGU/WtrlEWXBS1I/AAAAAAAAHHQ/qJAPrG-w4GQnwDVMCqOGS7WxZcs0yvVqQCHMYCw/I/IGList" alt="IGList学习2.015"/></p>

<p><img src="https://lh3.googleusercontent.com/-xVfRhZhIqW4/Wtrk0wQHw8I/AAAAAAAAHG4/zDN8RbMXFVQ7k7XGkh8Om2rxpwuqG7mfgCHMYCw/I/IGList" alt="IGList学习2.016"/></p>

<p><img src="https://lh3.googleusercontent.com/-au7HKcLFQ10/Wtrk00SFFZI/AAAAAAAAHGo/-vm-U10Uns82mP_rMaTJOBcgS8uObSevwCHMYCw/I/IGList" alt="IGList学习2.017"/></p>

<p><img src="https://lh3.googleusercontent.com/-gR-5TpG-AU0/Wtrk00YWqYI/AAAAAAAAHHE/fMxmOoGcAuQbA6lmshvaxIKotGyLQiV5QCHMYCw/I/IGList" alt="IGList学习2.018"/></p>

<p><img src="https://lh3.googleusercontent.com/-QLOsvoK3jeg/WtrlUU4hWlI/AAAAAAAAHHs/tpYFlDHN1I4JQCf9OYjexvbD_1LPynGWwCHMYCw/I/IGList" alt="IGList学习2.019"/></p>

<p><img src="https://lh3.googleusercontent.com/-917NY1ms0GA/Wtrk0wbzGrI/AAAAAAAAHHM/qGNzIBufKhUxx1MyktuCcOnvg5XJL-aKwCHMYCw/I/IGList" alt="IGList学习2.020"/></p>

<p><img src="https://lh3.googleusercontent.com/-9yccgBnoDjA/Wtrk0yz_5CI/AAAAAAAAHG0/bpQPDqHzGFsEq31WsEscWEuMLeVWYhbvACHMYCw/I/IGList" alt="IGList学习2.021"/></p>

<p><img src="https://lh3.googleusercontent.com/-98xFYuPBaUY/WtrlQhk-gpI/AAAAAAAAHHo/IkR7sJR_wPMfnWBm5invS_1pmZnGS03CACHMYCw/I/IGList" alt="IGList学习2.022"/></p>

<p><img src="https://lh3.googleusercontent.com/-aN1y0Bkj8dw/Wtrk2aXB7GI/AAAAAAAAHHA/9CL-kzrh91gdeGw31EPs114yWE_2zvQWACHMYCw/I/IGList" alt="IGList学习2.023"/></p>

<p><img src="https://lh3.googleusercontent.com/-oFyJ7-qenRc/WtrlOO4vhXI/AAAAAAAAHHk/QEIE11578DQiKq3k9PN-SldTvkNJvIvKwCHMYCw/I/IGList" alt="IGList学习2.024"/></p>

<p><img src="https://lh3.googleusercontent.com/-uqjxf9X08JU/WtrkGThqRwI/AAAAAAAAHF8/oxqZL78qvkQ-fGEJU1FFwRwZZN-Q68MBwCHMYCw/I/IGList" alt="IGList学习2.025"/></p>

<p><img src="https://lh3.googleusercontent.com/-yt48QkNQIkI/WtrkGdE1WcI/AAAAAAAAHFo/Kkw45BAWWdg8VAJAWOCs61rF4Jx_Sg01wCHMYCw/I/IGList" alt="IGList学习2.026"/></p>

<p><img src="https://lh3.googleusercontent.com/-9wqFeoP3HaU/WtrkpTOzMLI/AAAAAAAAHGg/VhFkvGAkqugvR4gpeZpgYr5R4_1Ovkn9wCHMYCw/I/IGList" alt="IGList学习2.027"/></p>

<p><img src="https://lh3.googleusercontent.com/-uxX91xjK2ms/Wtrkpe7IylI/AAAAAAAAHGc/5XoRUqFEFUYzWA08FVuKM4p0L6jqbuavACHMYCw/I/IGList" alt="IGList学习2.028"/></p>

<p><img src="https://lh3.googleusercontent.com/-4k-M1HZiR6k/WtrkpVL1CWI/AAAAAAAAHGY/a8SWRYV0M3ERhVmOyZxfNqkLCOeUuDVywCHMYCw/I/IGList" alt="IGList学习2.029"/></p>

<p><img src="https://lh3.googleusercontent.com/-N0gAtHcSFRg/WtrkpbnvZpI/AAAAAAAAHGk/9QMcmER3R4A93LNGXjVpGqDowOegzaArQCHMYCw/I/IGList" alt="IGList学习2.030"/></p>

<p><img src="https://lh3.googleusercontent.com/-n3dftairryw/WtrkF3i0XfI/AAAAAAAAHFU/H28ZO5XOX-AArZuJsSUgIdGuGAO15vSWQCHMYCw/I/IGList" alt="IGList学习2.031"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【IGListKit】ListDiff 学习与分析1]]></title>
    <link href="http://www.chaisong.xyz/15378876732151.html"/>
    <updated>2018-09-25T23:01:13+08:00</updated>
    <id>http://www.chaisong.xyz/15378876732151.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>源于4月2日在小组内的分享。<br/>
图床为Google相册，看不了自己准备梯子。</p>
</blockquote>

<p><img src="https://lh3.googleusercontent.com/-3jEV3avy7vY/WtriDp896UI/AAAAAAAAHDc/lCPKHvEM0CY7Gq1BugbSTZFkf60iD_SbQCHMYCw/I/ListDiff%2B" alt="ListDiff 学习与分析.001"/></p>

<p><img src="https://lh3.googleusercontent.com/-KfR_MU43kyc/WtrjMBGv0XI/AAAAAAAAHE0/aGRivjQBYMgz9LFzDQtIDz4o9QKDwfbSQCHMYCw/I/ListDiff%2B" alt="ListDiff 学习与分析.002"/></p>

<span id="more"></span><!-- more -->

<p><img src="https://lh3.googleusercontent.com/-KEsabtzFdk8/WtriDgDQ6XI/AAAAAAAAHDE/n0napZap9eUgjhkiMaRF3JMwgWsQO7wigCHMYCw/I/ListDiff%2B" alt="ListDiff 学习与分析.003"/></p>

<p><img src="https://lh3.googleusercontent.com/-QtPMmJFmsdQ/WtriDi7RGzI/AAAAAAAAHDI/BpvhNm8swTkGWM7CP46erar-SD--ojL-QCHMYCw/I/ListDiff%2B" alt="ListDiff 学习与分析.004"/></p>

<p><img src="https://lh3.googleusercontent.com/-pwrJkAPldWA/WtrjOxtQsLI/AAAAAAAAHE4/dexTWqWLn8AYaOfwBV-k9mgqlSVv6j-5QCHMYCw/I/ListDiff%2B" alt="ListDiff 学习与分析.005"/></p>

<p><img src="https://lh3.googleusercontent.com/-cZdtwRA6oM8/WtrjO4YNBAI/AAAAAAAAHE8/6p96Ts4kQCQWiTlnbvvi69lI9HUaQn0xwCHMYCw/I/ListDiff%2B" alt="ListDiff 学习与分析.006"/></p>

<p><img src="https://lh3.googleusercontent.com/-Gmda5Q6lofM/WtriDgRnzOI/AAAAAAAAHDQ/6e4VLqpSw1c_zSNNKSjvoyHB25IcsKuPgCHMYCw/I/ListDiff%2B" alt="ListDiff 学习与分析.007"/></p>

<p><img src="https://lh3.googleusercontent.com/-EPU_D5Gc4S4/WtrjSo1Ie0I/AAAAAAAAHFA/E5LKBYrksN8OvJqifYbLRWSTDVwsISSuwCHMYCw/I/ListDiff%2B" alt="ListDiff 学习与分析.008"/></p>

<p><img src="https://lh3.googleusercontent.com/-MqYic4U-Wvw/WtriDgDx8iI/AAAAAAAAHDY/6QbapA9_k3ESRlyTNK4MeRs3vhuUnC0_wCHMYCw/I/ListDiff%2B" alt="ListDiff 学习与分析.009"/></p>

<p><img src="https://lh3.googleusercontent.com/-3eojsu6usJA/Wtri8C4mhyI/AAAAAAAAHEg/rM4brr7eOX4ffaVNUMCBztaIX6rqwqqTQCHMYCw/I/ListDiff%2B" alt="ListDiff 学习与分析.010"/></p>

<p><img src="https://lh3.googleusercontent.com/-CRFLI035J_E/WtriDu9lu6I/AAAAAAAAHDU/Zayl7p_R_oE5XEkJtwBoABL9s64MLJKaACHMYCw/I/ListDiff%2B" alt="ListDiff 学习与分析.011"/></p>

<p><img src="https://lh3.googleusercontent.com/-M_fIlB0FudI/Wtri5lc_-0I/AAAAAAAAHEc/sD3aT4GPti0Mh2GvqP7taGyOInxwQatNwCHMYCw/I/ListDiff%2B" alt="ListDiff 学习与分析.012"/></p>

<p><img src="https://lh3.googleusercontent.com/-nFERUlMFYdk/WtriDl2L8II/AAAAAAAAHDM/q3P2y0ybqqsmLNJX5r00W89d0_SFgHPDwCHMYCw/I/ListDiff%2B" alt="ListDiff 学习与分析.013"/></p>

<p><img src="https://lh3.googleusercontent.com/-zxLw73SigmA/WtriDhQxWoI/AAAAAAAAHC8/KNhwkYMmavQTnueGty54lPz3-PMo7yt7gCHMYCw/I/ListDiff%2B" alt="ListDiff 学习与分析.014"/></p>

<p><img src="https://lh3.googleusercontent.com/-82bFCGc3G4Y/Wtriyfw7_PI/AAAAAAAAHEQ/8RrK1pilyyIPPjmF5d9Q-F7ni4UARijNwCHMYCw/I/ListDiff%2B" alt="ListDiff 学习与分析.015"/></p>

<p><img src="https://lh3.googleusercontent.com/-M7pYTQnCZqg/WtriyYDq8wI/AAAAAAAAHEU/DcugGQbWNK4534P45L3r7dLYEB8Gjx-_wCHMYCw/I/ListDiff%2B" alt="ListDiff 学习与分析.016"/></p>

<p><img src="https://lh3.googleusercontent.com/-7Mti9wMgdzU/WtriyWEgjdI/AAAAAAAAHEM/qkAZFyT6xTMEuXPOYnckabQ6c50UACFEgCHMYCw/I/ListDiff%2B" alt="ListDiff 学习与分析.017"/></p>

<p><img src="https://lh3.googleusercontent.com/-4yBs3SmLsBk/WtriDhv30FI/AAAAAAAAHC4/7sPLN1M4ayY9qsHnYake-bi0EeIUO5cNQCHMYCw/I/ListDiff%2B" alt="ListDiff 学习与分析.018"/></p>

<p><img src="https://lh3.googleusercontent.com/-Ezne7uiJQeA/WtriDkp7JHI/AAAAAAAAHDA/fDQLbOy5f4kDI__Sg4R_ZdOIX1I1N_7LwCHMYCw/I/ListDiff%2B" alt="ListDiff 学习与分析.019"/></p>

<p><img src="https://lh3.googleusercontent.com/-en735u-REJk/Wtrimd9UKQI/AAAAAAAAHEA/-tDwb5VF7MQbz6F6Cn4XFwQZyfx0W2SnQCHMYCw/I/ListDiff%2B" alt="ListDiff 学习与分析.020"/></p>

<p><img src="https://lh3.googleusercontent.com/-D1hsMxhquaM/WtrimQDbpyI/AAAAAAAAHD8/lDZQFklWNOgS9QS7qgPYSHEFJvKvWBQ_gCHMYCw/I/ListDiff%2B" alt="ListDiff 学习与分析.021"/></p>

<p><img src="https://lh3.googleusercontent.com/-l498mWLndBc/WtrimVBN90I/AAAAAAAAHEE/1ZpdsGb21csQfdzgLpVlenOgVLss7-NQwCHMYCw/I/ListDiff%2B" alt="ListDiff 学习与分析.022"/></p>

<p><img src="https://lh3.googleusercontent.com/-5LSSEOOU9ds/WtrimSI8nuI/AAAAAAAAHD4/-MCzJkU0MXAAtMlL44igIQj8LwaYsmQ-QCHMYCw/I/ListDiff%2B" alt="ListDiff 学习与分析.023"/></p>

<p><img src="https://lh3.googleusercontent.com/-4maoLl7X6KY/Wtrimzxm9XI/AAAAAAAAHEI/pMLQnpfjC-otVokJyDWFoZCmL077-FLqgCHMYCw/I/ListDiff%2B" alt="ListDiff 学习与分析.024"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[更新一下今年的学习计划]]></title>
    <link href="http://www.chaisong.xyz/15378876732185.html"/>
    <updated>2018-09-25T23:01:13+08:00</updated>
    <id>http://www.chaisong.xyz/15378876732185.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">1、工作上</h2>

<p>找到新的突破</p>

<h2 id="toc_1">2、学习</h2>

<p>一本英文书<br/>
Introduction to Computation and Programming Using Python(2nd)</p>

<h2 id="toc_2">3、身体</h2>

<p>一三五去健身，平均每周2小时健身房运动。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hello 2018]]></title>
    <link href="http://www.chaisong.xyz/15378876732218.html"/>
    <updated>2018-09-25T23:01:13+08:00</updated>
    <id>http://www.chaisong.xyz/15378876732218.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>写了两篇17年的感悟，这一篇写一下对18年的一些期望。</p>
</blockquote>

<h3 id="toc_0">新年寄语</h3>

<blockquote>
<p><strong>突破、胸怀、守时</strong><br/>
我希望，这三个寄语，能贯穿一年的主线，引领我一年的成长。</p>
</blockquote>

<p><strong>突破是我对一年最大的期望了。</strong><br/>
18年3月27日，是我头条入职1周年，也是我毕业参加工作4整年的日子。毕业后先去了微信，然后是好奇心日报，再到头条，作为一个iOS开发，已经4个年头，虽然成为了一个最基层的技术领导者，但瓶颈也随之出现。<br/>
今年，努力寻找在工作上肩负起更大的责任，或者在技术方向上寻找一个全新的领域。</p>

<p><strong>胸怀一个男人应有的素质</strong><br/>
18年，我即将会组建家庭，标志的成为一个完整的自然人，有道是成家立业。<br/>
随之而来的，是家庭生活，双方长辈的关系，琐事和纠纷也许也会不期而至。<br/>
有事做得好，有时做的差，其实都是家人，影响本身不大，重要的更多是态度。作为一个男人，在家庭中，尤其要有包容的胸怀，有心胸，能包容女人的脾气，能在婆媳中增加缓冲，永远起到积极的作用。<br/>
嗯，28年来，心胸这个词第一次进入了我的个人要求中，提到这个词，能感觉到自己的成长。</p>

<p><strong>守时是品德，想表达的更多是一些传统素质</strong><br/>
守信，应该是立于世界的基本品质，自认为一直坚持的不错，或者并不需要坚持，只需要不被错误引导即可。<br/>
但守时，毕业后渐渐堕落，和大家同流。虽有太多理由可以原谅自己。但我依旧相信，生活中有些东西，值得一直坚持，18年，言而有信从守时开始做起。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2017年的几点感悟]]></title>
    <link href="http://www.chaisong.xyz/15378876732252.html"/>
    <updated>2018-09-25T23:01:13+08:00</updated>
    <id>http://www.chaisong.xyz/15378876732252.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>一年又在没有一丝丝防备中到来而消去，回首一年，感受平静河流下面蕴含的一些汹涌，每天不知所踪的忙碌。<br/>
随波逐流，又想特立独行；有时怀疑自己，有时信心膨胀；会因别人转瞬的表情而患得患失。索性，那份全力以赴的热情，还未流失。</p>

<p>写这篇文章，主要描述一种感觉，沉淀一下2017年给自己带来的几点感悟，也希望指引一下有些迷茫的自己，寻找下一个突破</p>
</blockquote>

<h3 id="toc_0">一、初窥堂奥——一个技术领导者的起步</h3>

<p>跳槽还是不期而至，在好奇心日报没能坚持到第三年，之前写过一篇<a href="/2017/03/24/2017-03-24/">总结</a>，回顾了跳槽的心路历程。<br/>
头条是一家不错的公司，起码福利和待遇还是不错的。选择来头条，是因为相信这是一家一定会成功的公司，而自己，在这里有一个在个人职业阅历下，能拥有的还不错的坑。</p>

<span id="more"></span><!-- more -->

<h3 id="toc_1">二、管中窥豹——头条的内在逻辑</h3>

<blockquote>
<p>将来如果回忆起2017年，那跳槽来到头条一定是当年非常重要的关键词。<br/>
来到头条，管中窥豹，学习了一种生存逻辑，很神奇，也很颠覆。</p>
</blockquote>

<p>产品的能力应该体现在能把复杂的逻辑给用户看起来简单化；而不是为了实现方便只去做简单的处理，然后粗暴的通过AB测试后用数据来选择，嘴上说通过数据导向，其实是对复杂情况驾驭能力不够的体现。<br/>
微信的产品经理很多时间都是在思考，想产品逻辑，他们会把很多因果关系弄的很清楚，他们的观点很能说服人。就我个人在微信的工作经历，遇到的PM在给我设定需求的时候，都能让我心悦诚服的多写很多开发看起来恶心的代码；但在头条却很多情况都不会。<br/>
在头条，很多时候和PM争论逻辑（可能不仅PM），最终的杀手锏都是“这样弄数据好”，那些简单粗暴的数字经常噎的人哑口无言，因为这一刻，会给你感觉，你对面的不是一个人，是千千万万的用户，是整个头条的发展...<br/>
我一直认为，真正的产品经理一定能解释通自己的产品逻辑，这些逻辑来源于他个人的天赋、对产品的深刻理解、对用户行为的内在逻辑分析，他的逻辑能预测最终产品上线后的效果，也能解释通产品后的数据情况。当然，这只是“我以为”，这理想主义似得产品认知，完全来自于微信，来源于职业生涯的起点。</p>

<p>但反过来讲，用数据说话，理不清其内在的逻辑，使得头条对它的竞争对手带来的，恰似一种降维打击。面对头条杀入越来越多的领域，很多公司往往不会很恐惧，因为典型的思考模式是：“用头条的人，其实和我们的用户群重叠并不大”。头条的PM自己都离不清自己逻辑，别人又怎么能看得清呢？恰似独孤九剑吧，无招胜有招，任你千遍万化，我自AB测试。</p>

<h3 id="toc_2">三、包容——走向而立的男人</h3>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[17年的总结]]></title>
    <link href="http://www.chaisong.xyz/15378876732285.html"/>
    <updated>2018-09-25T23:01:13+08:00</updated>
    <id>http://www.chaisong.xyz/15378876732285.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>对我个人来讲，17年有两大收获，一是跳槽来了头条，二是找到了人生的另一半。<br/>
本该是事业有进步，爱情有收获，但发生了好多别的事情，使得这一年其实有些痛苦和无奈。</p>
</blockquote>

<h2 id="toc_0">衰老</h2>

<p>妈妈去年底的体检查出了宫颈癌病毒，我刚看到体检报告的时候一下子就懵了，后来发现其实没那么严重，上半年做了个锥切手术，但未能完全痊愈，需要持续观察才行，每念此处，都心绞一阵。<br/>
妈妈前几年血糖比较高，导致眼底出血，虽然做了激光手术，但也留下了永久的后遗症，前几天回家，发现妈妈视力越发的不好了，心疼。<br/>
由于我父亲，今年下半年父母发生了非常大的争吵，其中细节无心评述。心里对父亲充满怨念，包括上面说的妈妈两个病因，父亲都有直接或间接原因，也许我永远都不会原谅他了，看着他，心里总带着烦躁和鄙视。</p>

<h2 id="toc_1">投资</h2>

<p>妈妈去年年底像魔障了一样，手里稍微有点钱就想加大杠杆投资房产，在国家政策最为严厉的封口浪尖的4月份，依然坚持买了个门市楼，虽然后来她非常后悔，但木已成舟，悔之晚矣。<br/>
去年底今年初的慌乱房产投机，损失100多万，而且，彻底毁掉了一家三口人的现金流，同时背负了沉重的贷款债务，今年多次在睡前想起，然后辗转反侧难以入睡。<br/>
最终贷款压力主要在我身上，父母已老，不想太多说什么，只是这几年要对不住邹韵了。索性，妈妈陆续卖掉一些房产，略微缓解部分燃眉。</p>

<h2 id="toc_2">突破</h2>

<p>还算幸运，今年职场上再获一次突破，从好奇心日报的一个小技术团队的负责人，到了头条的一个小技术团队的技术leader，麻雀虽小，却收获颇多。<br/>
因为相信头条一定最后能成为一家了不起的公司，相信如果个人能随着公司的成长，会有更大的进步。<br/>
一年来，学会了一些流程、使用了一些工具、也了解了一些运转方式，有的东西很好玩，有的东西很无奈。<br/>
软实力提高很多，硬实力提高比较少，工作很忙，有时迷失了自己。<br/>
但尚好，没有盲目尊大，也没有妄自菲薄。<br/>
期望，能找到下一个突破。</p>

<h2 id="toc_3">爱情</h2>

<p>儿时好友的婚讯给了我不小的刺激，人有时就是不知道自己最终要的是什么，便如人生哲学有教育别人“今朝有酒今朝醉”，让人及时行乐；也有告诫人们“少壮不努力，老大徒伤悲”的励志警句。很多事情，回忆今天，难保会有遗憾和悔恨。<br/>
说遍了无病呻吟，今年的爱情其实是很顺利的，认识了邹韵，然后住在了一起，虽有时激情不高，但却和谐美好，邹韵是个可以白头的女孩，我很满意，也很开心。不管酸甜苦辣，愿能永远。</p>

<h2 id="toc_4">有点成绩？</h2>

<ul>
<li>因为换工作融入比较好，团队给力，所以有了一个还不错的绩效。但其实工作成果自己是不够满意的。</li>
<li>爱情基本稳定，即将走向婚姻</li>
<li>买了个还挺满意的房子，生活可以期待</li>
<li>开了大半年女朋友的车，生活体验高了不少</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UIResponder 响应链 拾遗]]></title>
    <link href="http://www.chaisong.xyz/15378876732321.html"/>
    <updated>2018-09-25T23:01:13+08:00</updated>
    <id>http://www.chaisong.xyz/15378876732321.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">背景</h2>

<p>基于ResponderChain可以做一些事件传递，将所有view的操作最终都送回到ViewController来处理，以实现view的功能单一性。如下：</p>

<pre><code class="language-text">@interface UIResponder (Router)
- (void)routerEventWithName:(NSString *)eventName userInfo:(NSDictionary *)userInfo;
@end

@implementation UIResponder (Router)
- (void)routerEventWithName:(NSString *)eventName userInfo:(NSDictionary *)userInfo
{
    [[self nextResponder] routerEventWithName:eventName userInfo:userInfo];
}
@end
</code></pre>

<p>每个cell在做事件请求时，只需要调用<code>routerEventWithName:userInfo:</code>，即可将请求传递给对应的ViewController（也可以是响应链任意一环），然后用EventName来区分事件类型。</p>

<h2 id="toc_1">ChildViewController</h2>

<p>一般来讲 view.nextResponder = view.superView。ViewController的root view的nextResponder是当前ViewController，那childViewController的view的nextResponder是谁呢？如果用nextResponder拦截，childViewController能拦截到其中的view的响应吗？</p>

<h3 id="toc_2">XCode实测：</h3>

<ul>
<li>如果addChildViewController：</li>
</ul>

<p>childVC.view.nextResponder == childVC，childVC.nextResponder == childVC.view.superView，相当于在subView&amp;superView的响应联调中，插入了一个VC，与window和VC.view的关系是一致的。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[博客继续记录]]></title>
    <link href="http://www.chaisong.xyz/15378876732356.html"/>
    <updated>2018-09-25T23:01:13+08:00</updated>
    <id>http://www.chaisong.xyz/15378876732356.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">博客继续记录</h3>

<p>3月底入职了头条，博客戛然而止。太忙了...</p>

<p>以前写了太多的技术上的东西，其实生活不仅仅有代码，以后多一些<strong>扯淡</strong>。</p>

<p>博客图片换了google的图床，嗯，想看肯定要有梯子。</p>

<p>域名又买了5年，才80。</p>

<p>评论在纠结于多说和网易云跟帖的关闭困境之后，终于找到了合适的替代品，机于github的issues的gitment应该是最优解。</p>

<p><strong>嗯 最重要的，以后还要多写点博客。</strong></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[简单处理不小心调用高版本API的问题]]></title>
    <link href="http://www.chaisong.xyz/15378876732390.html"/>
    <updated>2018-09-25T23:01:13+08:00</updated>
    <id>http://www.chaisong.xyz/15378876732390.html</id>
    <content type="html"><![CDATA[
<h1 id="toc_0">iOS API 版本检查</h1>

<blockquote>
<p>如果app兼容2个以上版本，那就需要注意低版本不能调用高版本API，为避免开发过程中不小心调用，必要的工具检查是必须的，下面介绍一种简单的方法处理。</p>
</blockquote>

<h3 id="toc_1">原理 ---- Clang</h3>

<p>2015 年 clang 本身增加 API 版本检查功能，通过 -Wpartial-availability 这个 flag 可以打开，后续版本把 flag 变成了 -Wunguarded-availability。打开之后，clang 会把所有在低版本 iOS 上调用高版本 API 的情况用 warning 暴露出来，如下图所示。</p>

<p><img src="https://lh3.googleusercontent.com/-zIv_o4Cf-0Q/WghOhF1OcuI/AAAAAAAAFiw/LJEY__p7Z_Ig2-FxfgJkOxxpJ_j9Q1c_QCHMYCw/I/15104938281303.jpg" alt=""/></p>

<p><img src="https://lh3.googleusercontent.com/-klYKWIBPS4o/WghOUy4CjqI/AAAAAAAAFis/DqPbsG4IXXAJeg5PuoP-mDIFKQ1721PngCHMYCw/I/15104937777800.jpg" alt=""/></p>

<h3 id="toc_2">具体实现</h3>

<ul>
<li>1、打开 <code>-Wunguarded-availability</code> 在调用高版本API时候报warning，为避免warning过多而忽视，用 <code>-Werror-unguarded-availability</code> 标记强制编译不过。</li>
<li>2、针对pod需要在 podspec 中添加<code>compiler_flags</code>。</li>
<li>3、如果代码本身安全（使用了 <code>respondsToSelector:</code> 保护），可以用 <code>#pragma clang diagnostic ignored</code> 的方式压掉警告，或者 <code>@available</code> 直接解决，如下图。</li>
</ul>

<p><img src="https://lh3.googleusercontent.com/-eGFR3umcjh8/WghPWGUvNoI/AAAAAAAAFi8/sndudmea1iIL0MiVnPwQvz3llHFqSCu4ACHMYCw/I/15104940402651.jpg" alt=""/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于Product Owner的思考]]></title>
    <link href="http://www.chaisong.xyz/15378876732425.html"/>
    <updated>2018-09-25T23:01:13+08:00</updated>
    <id>http://www.chaisong.xyz/15378876732425.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">关于Product Owner的思考</h2>

<blockquote>
<p>Product Owner是Scrum里面的概念，上周末和able哥吃饭听到了这个概念，最近看了一些相关的文章，得到了一些收获。</p>
</blockquote>

<ol>
<li>基本的能力，锻炼自己把技术问题抽象化，说出来让产品能理解的能力</li>
<li>了解项目背景，通过充分沟通摸索出一个需求的核心目标，了解到哪些是可以妥协的点，哪些是坚持的点，这样在遇到技术困难的时候可以从技术投入成本和产品产出收益（注意，这里不是技术收益）权衡是否需要提出来，如果提出来是否准备好了妥善的解决方案，有方案意见被接纳的可能性会增大</li>
<li>主动了解项目核心目标和关键性指标，了解策略和方案，了解 A/B 测试的分组策略和实验数据观察</li>
<li>了解产品做事的方式，他们是至上往下做产品，目标导向，我们技术在看产品设计的时候是一个反向的过程，本来就是在一个信息和理解不对称的过程，我们看到的是结果，看不到过程（就像我们看别人代码是一样的过程），这个时候要通过文档，沟通等方式去增强理解。产品 sense 不是一下就能提升的，同理心很重要。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[多说换成网易云跟帖，评论都丢了]]></title>
    <link href="http://www.chaisong.xyz/15378876732459.html"/>
    <updated>2018-09-25T23:01:13+08:00</updated>
    <id>http://www.chaisong.xyz/15378876732459.html</id>
    <content type="html"><![CDATA[
<p>多说关闭了，换个替代品，网易出品，应该不会没事就倒闭吧。</p>

<p>评论都导不出来了，不过也不是很多，以后评论从新开始吧。</p>

<hr/>

<h3 id="toc_0">10月更新</h3>

<p>没想到网易云跟帖也关闭了，以后彻底换disqu了，图床也换google了，不理墙内用户了。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[再见 好奇心日报]]></title>
    <link href="http://www.chaisong.xyz/15378876732493.html"/>
    <updated>2018-09-25T23:01:13+08:00</updated>
    <id>http://www.chaisong.xyz/15378876732493.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>昨天下午，收到了人生第二份《离职证明》，我也正式在法律上不再属于好奇心日报了。</p>

<p>写这篇文章，缅怀一下这两年的时光，因为这段工作的结束需要一个仪式感。<br/>
同时也鼓励我下一段工作，希望接下来在头条依然能够保持旺盛的学习和工作热情，保持谦卑和自省的态度。<br/>
祝愿好奇心日报越来越好！</p>
</blockquote>

<p>和好奇心日报的纠缠源于很早的外包，14年的一个周六晚上，中秋节前后，印象中天气很热，在TIT南边巷子里吃麻辣烫，广州麻辣烫的独有味道直到现在还让我流出口水。徐源说有个Android外包要做，做不？我说，当然做。那会儿事情不多，微信的工作虽然忙碌但压力不大，而且很规律。</p>

<span id="more"></span><!-- more -->

<p>当时已经有小半年没碰过Android的开发了，在微信新学习的iOS对我来讲挑战很大，也很有劲。工程建好的时候，感觉对eclipse、对java都很生疏，我很害怕，难道以前的本事都不会了吗？Android studio当时已经被google放出来1年了，但依然不像现在这么稳定，鉴于eclipse也生疏了，而且是独立开发，我果断转型了新IDE，现在想想当初付出的辛苦和努力是多么的正确。<br/>
那会儿我的Android开发技术和思想都很初级，初级到我都不忍心浏览当初的代码。从外包开始到现在这两年多以来，我见证了好奇心日报的成长，好奇心日报也见证了我技术的成熟。</p>

<p>再后来，公司一直找不到合适的客户端开发，我就先后维护了iOS和Android两端的几个小版本，可能是公司感觉我还挺认真的吧，技术也不错，几个创始人萌生了挖我过去的想法。<br/>
没错，一开始，我是抗拒的。</p>

<p>但随着时间增加，心态慢慢有了变化。<br/>
在广州的一年，我的个人感情都停留在上一段的失败阴影中，对于爱情都比较抗拒，一直单身。<br/>
广州是一个粤语环境很浓郁的地方，有很强的本土文化，我又是一个在语言上毫无天赋的人，一直像一个旁观者在自己活着。<br/>
那时候和两个单身男生一起合租，微信下班很晚，我要11点多才到家，如果在工作日，我到家时房间是黑的，所有人都睡了，但如果放假前一天，我9点多就回去了，家里还是黑的，所有人都出去过节了。每当此时，都有一种浓郁的独在异乡为异客之感。</p>

<p>再后来，徐源和黄老师去广州专门找了我，说实话，那会太年轻，我没见过市面，没见过钱，确实心动了。而且当时齐修已经加入好奇心了，我想，他都认为不错，可能确实是个好机会吧。人一旦动心，好多时候就不可抗拒了，尽管后来好多条件没有和期望中那么好，我还是在年后突破阻力，毅然回到了北京，中途仅仅休息了一天，记得是周一离职的，周三就在这边入职了。</p>

<p>在好奇心日报，先是建立了整个Android的技术栈，微信给我最大的财富不是这个金子招牌，是教会了我的学习能力。</p>

<p>来了好奇心后，我的第一个下属是陈成，他是个很了解市面上开源框架的人，在修改和review他的代码过程中，我看了很多知名的开源库，了解了很多实现，以非常快的速度hold住了Android项目，终于打开了工作局面。那时候比较闲，我甚至养了一只小狗，她叫奥莉，但很不幸，后来她成为了我一直的伤痛。</p>

<p>刚入职的时候，有个叫张炜的iOS开发，我名义上是他的上级，却从没有真正领导过他。他性格很强，技术很好，我在他身上学会了很多，尤其是他后来留下的iOS代码，给我开阔了很多思维。</p>

<p>第二个真正意义的下属叫都基鹏，他也是个iOS开发，水平中规中矩，人有点懒惰，他和陈成一样，是在我之前就已经在公司的老员工，我作为空降领导其实在其中的关系是很复杂的，第一次带团队，遇上这些情况对我是个挑战。</p>

<p>入职不久，丁锟就来了我这里，帮我做Android客户端。他是我的发小，我多年的同学，我的好朋友、好哥们。他想向互联网方向转型，我也需要团队里有个“自己人”，所以就利用职务之便，把毫无经验的他拉过来做我手下。这是我第三个下属，丁锟很聪明，学东西快，但毕竟不是计算机出身，行业跨度很大，在他身上培养我也使了很多劲，也担心他以后会后悔自己的选择。索性，他现在已经混出来了，不在需要我带他了，我也替他高兴。</p>

<p>再后来，我先后又招了四个同事，随着人员流动，项目前进，制度建立，终于完善了队伍。好奇心日报也从1.0版本到了现在的3.3.6版本，可以说，每个版本都倾注着我的心血。</p>

<p>15年下半年到16年年初，我工作特别辛苦，几乎天天加班。<br/>
先是广告上线，当时后台技术也不成熟，半夜起来处理问题无数，印象深刻的被电话叫醒就足足有3次，其中两次来公司，另外一次在家搞到4点电脑没电，6点起床后来公司继续。<br/>
再之后是iPad版本，这是我投入了很多精力的一个版本，时间非常紧张，但事实上完成的很漂亮，1年多都没做过什么修复，扩展性和维护性都还不错，是我见过市面上对split view支持最好的一个iPad app。<br/>
然后就是紧张的3.0版本，一个翻天覆地的改变却要求在短短的1个多月完成，那会的脾气暴躁，火几乎一点就着，一直到16年春节前三天还在加班，最后几天我高烧到39度，这是我这两年唯一一次得病，年前2天的时候半夜我们提包，一直在公司到3点多，索性这个版本也很漂亮，上线后没什么大的问题，一切还算顺利。</p>

<p>3.0完成在16年年初，我当时非常不满意当时的工作，反感公司不重视技术团队，反感外行管理内行，反感上级的管理艺术太过粗暴，反感公司的薪酬和福利制度...同时，也对公司的发展心存悲观。<br/>
新年后，3.0版本稳定了，我找徐源谈，我说，出来工作，都是为了赚钱，或者现在给钱多，或者以后能发展好，公司现在给的薪水低于外面的，个人技术又没什么提高，而且公司也迟迟看不到爆发点，我打算离开了。那是16年的2月底三月初吧，和现在时间差不多，我当时面试了5家公司，拿了其中的4个offer，底气很足。<br/>
然而公司没有很使劲的挽留，我却也没走，可能是第一次跳槽之后，我对跳槽很谨慎吧；也可能公司给了薪水的提升，外面的薪水也没那么有吸引力了，而且徐源也承诺改变一些制度，承诺扩充团队的，让我权衡起来还想再看一年吧；也有可能当时勇哥加入公司，让我又对公司的发展燃起希望了吧？</p>

<p>大规模招人也在我决定留下开始，上面说的又招来的4个同事都是那之后的事情了。<br/>
16年这一年，我完善组建了团队，慢慢从一个工程师转变成了架构师和真正的team leader，有了项目管理、代码管理和团队管理建设的经验和心得。<br/>
16年这一年，由于个人争取的缘故，多了个人学习的时间，完整的看了很多的Android和iOS领域的开源代码，提高了很多。<br/>
16年这一年，由于位置的缘故，在团队大胆采用react native，扩展了技术栈，开阔了视野，感觉没有虚度自己的光阴。</p>

<p>然而，小团队的瓶颈也在不断的收获后越来越清晰，虽然薪水还不错，但我还是希望更多的提高，我希望能在深度上有更多的学习，更好的平台，以及更清晰的公司发展。这一次我的目标很明确，只面试了3个公司，也非常幸运的拿到了全部的offer，分别是支付宝、今日头条和快手。支付宝是我当时最想去的公司，慕名其光环；头条是在16年面试的时候认识了俞鑫，他知道我一直希望寻求一个team leader的角色，可能我在之前的面试他非常满意吧，这一次头条扩张业务线主动邀请了我；快手其实没那么渴望去，是那会等待支付宝和头条offer时候比较无聊，武泽推荐的，慕名其土豪的名声～<br/>
从个人的职业生涯规划来讲，头条的这个职位是最理想的选择，我甚至没有一点算计薪水情况，诚然薪水我也很满意。这一次，没有纠结，我很坚定，也跃跃欲试，希望到头条创造更多的价值。</p>

<p>从头到尾，在好奇心日报一共工作了23个月，包含之前在微信的13个月，工作了整整3年。<br/>
我最感谢好奇心日报的，是它带给我宽松和自由的时间，我的母亲在15年出现了眼底出血，去过很多次医院，我甚至不用请假就可以一上午一上午的陪她辗转于医院和家里，做激光手术的时候经常下午3点多才到公司，这份福利我一直享受到现在，这周的所有上午，我依然陪着我的母亲周转与3个医院之间。<br/>
还有，我要感谢好奇心日报，感谢徐源，信任我给了我独当一面的机会，从更好的高度看待一个app，看待客户端的技术栈，学习了技术，也锻炼了团队管理技巧。<br/>
我还要感谢我的组员，我第一次带队伍，很多次试错，他们给了我的宽容和温暖。<br/>
而且，在好奇心日报这两年，由于工作环境的宽松，我和父母先后在北京、香河、燕郊买了3个房子，二手房的手续繁多复杂，如果在其它公司，很难有这么充裕的时间。也得益于公司在北京东部，我才有这么方便的机会。</p>

<p>前天，在组内做交接，我讲了很多设计上的思考和代码的规范，最后我说，这些都是我的建议，反正，以后是你们来写，爱怎么写就这么写吧，反正，这些代码就交给你们了。<br/>
说完我眼睛就湿了。</p>

<p>写到这，想起下午和邹韵说的话，“好奇心日报的Android和iOS客户端，从1.0版本到现在，它的每个功能，每次改版，每个优化，每一行代码都倾注我的心血，从明天开始，它就归别人管了”。</p>

<p>附两个合影吧，纪念我这次热血的经历：</p>

<p><img src="http://obp30zydr.bkt.clouddn.com/qdailyteam1.jpeg" alt="qdailyteam1"/></p>

<p><img src="http://obp30zydr.bkt.clouddn.com/qdailyteam2.jpeg" alt="qdailyteam2"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【iOS】从同步锁到多线程]]></title>
    <link href="http://www.chaisong.xyz/15378876732528.html"/>
    <updated>2018-09-25T23:01:13+08:00</updated>
    <id>http://www.chaisong.xyz/15378876732528.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>年前年后，忙的事情太多，没有继续更新博客，打算近期总结下过往。</p>

<p>如果每天只是做需求，写UI，可能不需要知道太多多线程的知识。也许简单的GCD会使用，再加几个开源框架，大多数功能都能实现。但如果你想写个框架，开源出来，那多线程就是一个永远绕不开的话题。除非你是一个前端开发者，否则无论在公司里，还是供自己娱乐，如果你想把技术走向深入，那多线程都是必须要明白的事。</p>

<p>本文先从iOS中objective-c的多线程同步开始，给iOS下的多线程做一个概述。</p>
</blockquote>

<h2 id="toc_0">一、几种线程同步方式</h2>

<h3 id="toc_1">1、自旋锁 <code>OSSpinLock</code></h3>

<p>上测试代码</p>

<pre><code class="language-objectivec">__block OSSpinLock oslock = OS_SPINLOCK_INIT;
    
//线程2
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{
   NSLog(@&quot;线程2 准备上锁&quot;);
   OSSpinLockLock(&amp;oslock);
   NSLog(@&quot;线程2&quot;);
   OSSpinLockUnlock(&amp;oslock);
   NSLog(@&quot;线程2 解锁成功&quot;);
});
//线程1
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0), ^{
   NSLog(@&quot;线程1 准备上锁&quot;);
   OSSpinLockLock(&amp;oslock);
   NSLog(@&quot;线程1 sleep&quot;);
   sleep(4);
   NSLog(@&quot;线程1&quot;);
   OSSpinLockUnlock(&amp;oslock);
   NSLog(@&quot;线程1 解锁成功&quot;);
});
</code></pre>

<p>虽然YY大神<a href="http://blog.ibireme.com/">http://blog.ibireme.com/</a>说其已经不再安全，但GCD在多线程实际应用过程中，未发现问题，并行线程只要获取到oslock，其它线程一律阻塞（非睡眠），直到之前获取的解锁为止，上述代码QUEUE优先级相差较大，在实际使用中未发生高优先级忙等状态。</p>

<!--more-->

<blockquote>
<p>低优先级线程拿到锁时，高优先级线程进入忙等(busy-wait)状态，消耗大量 CPU 时间，从而导致低优先级线程拿不到 CPU 时间，也就无法完成任务并释放锁。这种问题被称为<code>优先级反转</code>。</p>
</blockquote>

<p>可以在同一线程无限制上锁，但必须成对出现解锁，否则会死锁。可以在同一线程无限制调用解锁，但如果没有获取锁，解锁代码无效。</p>

<p><strong><em>结论</em></strong>：QUEUE的优先级和CPU调度的线程优先级可能并不是一回事，实际运用GCD来进行多线程开发时，可以应用自旋锁进行数据同步。</p>

<h3 id="toc_2">2、信号量 <code>dispatch_semaphore</code></h3>

<p>上测试代码</p>

<pre><code class="language-objectivec">dispatch_semaphore_t signal = dispatch_semaphore_create(1);
dispatch_time_t timeout = dispatch_time(DISPATCH_TIME_NOW, 3.0f * NSEC_PER_SEC);
    
//线程1
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
   NSLog(@&quot;线程1 等待ing&quot;);
   dispatch_semaphore_wait(signal, timeout); //signal 值 -1
   NSLog(@&quot;线程1 sleep&quot;);
   sleep(2);
   NSLog(@&quot;线程1&quot;);
   dispatch_semaphore_signal(signal); //signal 值 +1
   NSLog(@&quot;线程1 发送信号&quot;);
});
    
//线程2
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
   NSLog(@&quot;线程2 等待ing&quot;);
   dispatch_semaphore_wait(signal, timeout);
   NSLog(@&quot;线程2 sleep&quot;);
   sleep(2);
   NSLog(@&quot;线程2&quot;);
   dispatch_semaphore_signal(signal);
   NSLog(@&quot;线程2 发送信号&quot;);
});
</code></pre>

<p>信号量dispatch_semaphore被称为spinlock的替代方案。（引<a href="http://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/">http://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/</a>）<br/>
使用方法非常简单，dispatch_semaphore_create(1)为创建信号，数字表示可以同时几个线程使用信号。为1表示同步使用。上述代码如果此处标2就和没设置信号量一样，并发自行运行。如果设置为0，则一律等待overTime时自动释放，所有代码都不执行，理论上也具有同步作用，就是慢点...<br/>
dispatch_semaphore_wait中传入的timeout表示最长加锁时间，此处sleep如果为4，则在3s后会自动释放锁，其它线程可以获取信号并继续运行。</p>

<p>和厕所坑位类似，dispatch_semaphore_create(1)表示只有1个坑位，timeout = dispatch_time(DISPATCH_TIME_NOW, 3.0f * NSEC_PER_SEC)表示坑位只能占用3秒。无论是否当前线程，坑位都一致。可以在同一线程频繁调用dispatch_semaphore_wait，在只有一个坑位且没有dispatch_semaphore_signal信号情况下，会等到每次的timeout。所以理论上可以不成对出现。</p>

<blockquote>
<p>semaphore [&#39;sɛməfɔr] ： 信号；旗语；</p>
</blockquote>

<h3 id="toc_3">3、互斥锁 <code>pthread_mutex</code></h3>

<p>看测试代码</p>

<pre><code class="language-text">static pthread_mutex_t pLock;
pthread_mutex_init(&amp;pLock, NULL);
    
//1.线程2
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{
   NSLog(@&quot;线程2 准备上锁&quot;);
   pthread_mutex_lock(&amp;pLock);
   NSLog(@&quot;线程2&quot;);
   pthread_mutex_unlock(&amp;pLock);
});
    
//2.线程1
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
   NSLog(@&quot;线程1 准备上锁&quot;);
   pthread_mutex_lock(&amp;pLock);
   sleep(3);
   NSLog(@&quot;线程1&quot;);
   pthread_mutex_unlock(&amp;pLock);
});
</code></pre>

<p>pthread 表示 POSIX thread，定义了一组跨平台的线程相关的 API，pthread_mutex 表示互斥锁。<br/>
使用上没啥说的，测试效果和上文一致。<br/>
非递归锁，同一线程重复调用加锁会造成死锁。</p>

<h4 id="toc_4"><code>pthread_mutex(recursive)</code> 递归锁</h4>

<p>测试代码</p>

<pre><code class="language-text">static pthread_mutex_t pLock;
pthread_mutexattr_t attr;
pthread_mutexattr_init(&amp;attr); //初始化attr并且给它赋予默认
pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE); //设置锁类型，这边是设置为递归锁
pthread_mutex_init(&amp;pLock, &amp;attr);
pthread_mutexattr_destroy(&amp;attr); //销毁一个属性对象，在重新进行初始化之前该结构不能重新使用
    
//1.线程1
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
   static void (^RecursiveBlock)(int);
   RecursiveBlock = ^(int value) {
       pthread_mutex_lock(&amp;pLock);
       if (value &gt; 0) {
           NSLog(@&quot;value: %d&quot;, value);
           RecursiveBlock(value - 1);
       }
       
   };
   NSLog(@&quot;线程1 准备上锁&quot;);
   RecursiveBlock(5);
   NSLog(@&quot;线程1&quot;);
   pthread_mutex_unlock(&amp;pLock);
   NSLog(@&quot;线程1 解锁&quot;);
});
    
//2.线程2
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
   NSLog(@&quot;线程2 准备上锁&quot;);
   pthread_mutex_lock(&amp;pLock);
   NSLog(@&quot;线程2&quot;);
   pthread_mutex_unlock(&amp;pLock);
   NSLog(@&quot;线程2 解锁&quot;);
});
</code></pre>

<p>递归锁比较安全，可以认为同一线程加且仅加一次锁，重复加锁不会造成死锁。无论同一线程加锁多少次，解锁1次即可。</p>

<h3 id="toc_5">4&amp;5、NS前缀的两个锁<code>NSLock</code>、<code>NSRecursiveLock</code></h3>

<p>使用比较简单，效果基本对应上述两种情况</p>

<pre><code class="language-text">NSLock *lock = [NSLock new];
[lock lock];
NSLog(@&quot;加锁运行&quot;);
[lock unlock];
    
NSRecursiveLock *recursiveLock = [NSRecursiveLock new];
[recursiveLock lock];
NSLog(@&quot;加锁运行&quot;);
[recursiveLock unlock];
</code></pre>

<p>NS开头的类都是对CoreFoundation的封装，只是易用一些。NSRecursiveLock为递归锁，可以在循环和递归中使用。<br/>
这里NSLock和NSRecursiveLock都是封装的互斥锁<code>pthread_mutex</code>。<br/>
NSLock 只是在内部封装了一个 pthread_mutex，属性为 PTHREAD_MUTEX_ERRORCHECK，它会损失一定性能换来错误提示。理论上 NSLock 和 pthread_mutex 拥有相同的运行效率，实际由于封装的原因，会略慢一点，由于有缓存存在，相差不会很多，属于相同数量级。<br/>
NSRecursiveLock 与 NSLock 的区别在于内部封装的 pthread_mutex_t 对象的类型不同，NSRecursiveLock 的类型为 PTHREAD_MUTEX_RECURSIVE。</p>

<h3 id="toc_6">6、<code>NSCondition</code></h3>

<p>顾明思意，条件锁，一种生产者---消费者模型。<br/>
它通常用于标明共享资源是否可被访问或者确保一系列任务能按照指定的执行顺序执行。如果一个线程试图访问一个共享资源，而正在访问该资源的线程将其条件设置为不可访问，那么该线程会被阻塞，直到正在访问该资源的线程将访问条件更改为可访问状态或者说给被阻塞的线程发送信号后，被阻塞的线程才能正常访问这个资源。</p>

<h3 id="toc_7">7、条件锁 <code>NSConditionLock</code></h3>

<p>这里和NSLock主要区别是增加了一个NSInteger类型的condition参数，api很简单，也很少。condition就是一个条件标识。在加锁和解锁时对NSConditionLock做条件判断和修改，相当于if语句。</p>

<pre><code class="language-text">NSConditionLock *cLock = [[NSConditionLock alloc] initWithCondition:0];
    
//线程2
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{
   [cLock lockWhenCondition:1];
   NSLog(@&quot;线程2&quot;);
   [cLock unlockWithCondition:3];
});
//线程1
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0), ^{
   if([cLock tryLockWhenCondition:0]){
       NSLog(@&quot;线程1&quot;);
       [cLock unlockWithCondition:1];
   }else{
       NSLog(@&quot;失败&quot;);
   }
});
    
//线程3
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
   [cLock lockWhenCondition:3];
   NSLog(@&quot;线程3&quot;);
   [cLock unlockWithCondition:2];
});
</code></pre>

<p>上述代码会按照：线程1--&gt;线程2--&gt;线程3按顺序执行。</p>

<p>实际的实现原理就是里面封装了一个NSCondition对象，在lock时判断NSCondition对象的条件是否满足，不满足则wait，unlock时对发送NSCondition的broadcast，属于一个常见的生产者--消费者模型。</p>

<h3 id="toc_8">8、简单易用的条件锁 <code>@synchronized</code></h3>

<pre><code class="language-text">@synchronized (self) {
   NSLog(@&quot;加锁运行&quot;);
}
</code></pre>

<p>只要关键字中的对象一致，则多个线程会互斥等待程序运行完成。<br/>
@synchronized 实际上是把修饰对象当做锁来使用。这是通过一个哈希表来实现的，OC 在底层使用了一个互斥锁的数组(你可以理解为锁池)，通过对对象去哈希值来得到对应的互斥锁。</p>

<h2 id="toc_9">二、5S下测试一千万次加锁解锁时间测试</h2>

<p><strong>注意</strong> ：线程锁性能的加锁和解锁耗时并不能准确反映锁的效率（因为锁的效率还要综合考虑CPU时间片切换），它只能从一定程度上反映锁的实现复杂度。</p>

<p><img src="http://obp30zydr.bkt.clouddn.com/2017-02-06-1.jpg" alt=""/></p>

<p><img src="http://obp30zydr.bkt.clouddn.com/2017-02-06-2.jpg" alt=""/></p>

<p>上代码：</p>

<pre><code class="language-objectivec">#define ITERATIONS (10000000) // 1千万
+ (void)test
{
    double then, now;
    
    @autoreleasepool {
        
        // 普通锁 NSLock
        NSLock *lock = [NSLock new];
        then = CFAbsoluteTimeGetCurrent();
        for(NSInteger i = 0; i &lt; ITERATIONS; ++i)
        {
            [lock lock];
            [lock unlock];
        }
        now = CFAbsoluteTimeGetCurrent();
        NSLog(@&quot;NSLock: %f sec\n&quot;, now-then);
        
        // 互斥锁 pthread_mutex
        pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
        then = CFAbsoluteTimeGetCurrent();
        for(NSInteger i = 0; i &lt; ITERATIONS; ++i)
        {
            pthread_mutex_lock(&amp;mutex);
            pthread_mutex_unlock(&amp;mutex);
        }
        now = CFAbsoluteTimeGetCurrent();
        NSLog(@&quot;pthread_mutex: %f sec\n&quot;, now-then);
        
        // 递归锁 pthread_mutex(recursive)
        static pthread_mutex_t pLock;
        pthread_mutexattr_t attr;
        pthread_mutexattr_init(&amp;attr); //初始化attr并且给它赋予默认
        pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE); //设置锁类型，这边是设置为递归锁
        pthread_mutex_init(&amp;pLock, &amp;attr);
        pthread_mutexattr_destroy(&amp;attr); //销毁一个属性对象，在重新进行初始化之前该结构不能重新使用
        
        then = CFAbsoluteTimeGetCurrent();
        for(NSInteger i = 0; i &lt; ITERATIONS; ++i)
        {
            pthread_mutex_lock(&amp;pLock);
            pthread_mutex_unlock(&amp;pLock);
        }
        now = CFAbsoluteTimeGetCurrent();
        NSLog(@&quot;pthread_mutex(recursive): %f sec\n&quot;, now-then);
        
        // 自旋锁 OSSpinlock
        OSSpinLock spinlock = OS_SPINLOCK_INIT;
        then = CFAbsoluteTimeGetCurrent();
        for(NSInteger i = 0; i &lt; ITERATIONS; ++i)
        {
            OSSpinLockLock(&amp;spinlock);
            OSSpinLockUnlock(&amp;spinlock);
        }
        now = CFAbsoluteTimeGetCurrent();
        NSLog(@&quot;OSSpinlock: %f sec\n&quot;, now-then);
        
        // synchronized
        id obj = [NSObject new];
        then = CFAbsoluteTimeGetCurrent();
        for(NSInteger i = 0; i &lt; ITERATIONS; ++i)
        {
            @synchronized(obj)
            {
            }
        }
        now = CFAbsoluteTimeGetCurrent();
        NSLog(@&quot;@synchronized: %f sec\n&quot;, now-then);
        
        // dispatch_semaphore
        dispatch_semaphore_t lockSemaphore = dispatch_semaphore_create(1);
        then = CFAbsoluteTimeGetCurrent();
        for(NSInteger i = 0; i &lt; ITERATIONS; ++i)
        {
            dispatch_semaphore_wait(lockSemaphore, DISPATCH_TIME_FOREVER);
            dispatch_semaphore_signal(lockSemaphore);
        }
        now = CFAbsoluteTimeGetCurrent();
        NSLog(@&quot;dispatch_semaphore: %f sec\n&quot;, now-then);
        
        
        NSCondition *cLock = [NSCondition new];
        then = CFAbsoluteTimeGetCurrent();
        for(NSInteger i = 0; i &lt; ITERATIONS; ++i)
        {
            [cLock lock];
            [cLock unlock];
        }
        now = CFAbsoluteTimeGetCurrent();
        NSLog(@&quot;NSCondition: %f sec\n&quot;, now-then);
        
        
        NSRecursiveLock *rLock = [NSRecursiveLock new];
        then = CFAbsoluteTimeGetCurrent();
        for(NSInteger i = 0; i &lt; ITERATIONS; ++i)
        {
            [rLock lock];
            [rLock unlock];
        }
        now = CFAbsoluteTimeGetCurrent();
        NSLog(@&quot;NSRecursiveLock: %f sec\n&quot;, now-then);
        
        // dispatch_barrier_async
        dispatch_queue_t queue = dispatch_queue_create(&quot;xyz.chaisong.lock&quot;, DISPATCH_QUEUE_SERIAL);
        then = CFAbsoluteTimeGetCurrent();
        for(NSInteger i = 0; i &lt; ITERATIONS; ++i)
        {
            dispatch_barrier_async(queue, ^{
            });
        }
        now = CFAbsoluteTimeGetCurrent();
        NSLog(@&quot;dispatch_barrier_async: %f sec\n&quot;, now-then);
    }
}
</code></pre>

<p>上述的dispatch_barrier_async只是GCD的一种数据同步方案，并不属于锁，这里只比较多线程同步方案的效率。</p>

<p><strong><em>结论</em></strong>，单从效率上来看<code>dispatch_barrier_async</code>和<code>@synchronized</code>差的比较多，不建议使用，其它整体相差不大；相同类型的锁递归锁和普通锁效率相差接近一倍，如果不会在循环或者递归中频繁使用加锁和解锁，不建议使用递归锁；<code>OSSpinlock</code>各路大神都说有问题，从效率上讲，建议用互斥锁<code>pthread_mutex</code>（YYKit方案）或者信号量<code>dispatch_semaphore</code>（CoreFoundation和protobuf方案）作为替代。<br/>
OSpinlock为什么效率奇高主要原因是：并没有进入系统kernel，使用它可以节省系统调用和上下文切换。</p>

<h2 id="toc_10">三、一些多线程的基础知识</h2>

<h3 id="toc_11">1、时间片轮转调度算法</h3>

<p>了解多线程加锁必须知道时间片轮转调度算法，才能深切理解其原理、性能瓶颈。<br/>
现代操作系统在管理普通线程时，通常采用时间片轮转算法(Round Robin，简称 RR)。每个线程会被分配一段时间片(quantum)，通常在 10-100 毫秒左右。当线程用完属于自己的时间片以后，就会被操作系统挂起，放入等待队列中，直到下一次被分配时间片，如果线程在时间片结束前阻塞或结束，则CPU当即进行切换。由于线程切换需要时间，如果时间片太短，会导致大量CPU时间浪费在切换上；而如果这个时间片如果太长，会使得其它线程等待太久；</p>

<h3 id="toc_12">2、原子操作</h3>

<p>狭义上的原子操作表示一条不可打断的操作，也就是说线程在执行操作过程中，不会被操作系统挂起，而是一定会执行完（理论上拥有CPU时间片无限长）。在单处理器环境下，一条汇编指令显然是原子操作，因为中断也要通过指令来实现，但一句高级语言的代码却不是原子的，因为它最终是由多条汇编语言完成，CPU在进行时间片切换时，大多都会在某条代码的执行过程中。<br/>
但在多核处理器下，则需要硬件支持，没了解过具体实现。</p>

<h3 id="toc_13">3、自旋锁和互斥锁</h3>

<p>都属于CPU时间分片算法下的实现保护共享资源的一种机制。都实现互斥操作，加锁后仅允许一个访问者。<br/>
却别在于自旋锁不会使线程进入wait状态，而通过轮训不停查看是否该自旋锁的持有者已经释放的锁；对应的，互斥锁在出现锁已经被占用的情况会进入wait状态，CPU会当即切换时间片。</p>

<h4 id="toc_14">自旋锁实现原理</h4>

<p>简单的while循环</p>

<pre><code class="language-text">lock = 0;
do{
    while(test_and_set(&amp;lock));
    临界区
    lock = 0;
    其余部分
} while(1)
</code></pre>

<p>test_and_set用来保证条件判断的原子性操作，lock为旗标。<br/>
自旋锁的一大缺陷是会使得线程处于忙等状态。因为如果临界区执行时间过长，其它线程就会在当前整个时间片一直处于忙等状态，浪费大量CPU时间。所以，如果临界区时间很短，可以使用自旋锁，否则建议使用互斥锁。</p>

<h4 id="toc_15">互斥锁的实现原理</h4>

<p>互斥锁在出现锁的争夺时，未获得锁的线程会主动让出时间片，阻塞线程并睡眠，需要进行上下文切换，CPU会切换其它线程继续操作。<br/>
主动让出时间片并不总是代表效率高。让出时间片会导致操作系统切换到另一个线程，这种上下文切换通常需要 10 微秒左右，而且至少需要两次切换。如果等待时间很短，比如只有几个微秒，忙等就比线程睡眠更高效。</p>

<h4 id="toc_16">信号量的实现</h4>

<pre><code class="language-text">int sem_wait (sem_t *sem) {  
  int *futex = (int *) sem;
  if (atomic_decrement_if_positive (futex) &gt; 0)
    return 0;
  int err = lll_futex_wait (futex, 0);
    return -1;
)
</code></pre>

<p>信号量和互斥锁类似，都是在获取锁失败后线程进入wait状态，CPU会切换时间片。<br/>
信号量在最终都是调用一个sem_wait方法，并原子性的判断信号量，如果对其-1后依然大于0，则直接返回，继续临界区操作，否则进入等待状态。</p>

<p>参考：<a href="https://bestswifter.com/ios-lock/">https://bestswifter.com/ios-lock/</a></p>

<h2 id="toc_17">四、多线程中的常见术语</h2>

<ul>
<li>条件(condition)<br/>
一个用来同步资源访问的结构。线程等待某一条件来决定是否被允许继续运行，直到其他线程显式的给该条件发送信号。</li>
<li>临界区(critical section)<br/>
同一时间只能不被一个线程执行的代码。</li>
<li>输入源(input source)<br/>
一个线程的异步事件源。输入源可以是基于端口的或手工触发，并且必须被附加到某一个线程的run loop上面。</li>
<li>可连接的线程(join thread)<br/>
退出时资源不会被立即回收的线程。可连接的线程在资源被回收之前必须被显式脱离或由其他线程连接。可连接线程提供了一个返回值给连接它的线程。</li>
<li>主线程(main thread)<br/>
当创建进程时一起创建的特定类型的线程。当程序的主线程退出，则程序即退出。</li>
<li>互斥锁(mutex)<br/>
提供共享资源互斥访问的锁。一个互斥锁同一时间只能被一个线程拥有。试图获取一个已经被其他线程拥有的互斥锁，会把当前线程置于休眠状态知道该锁被其他线程释放并让当前线程获得。</li>
<li>操作对象(operation object)<br/>
NSOperation类的实例。操作对象封装了和某一任务相关的代码和数据到一个执行单元里面。</li>
<li>操作队列(operation queue)<br/>
NSOperationQueue类的实例。操作队列管理操作对象的执行。</li>
<li>进程(process)<br/>
应用或程序的运行时实例。一个进程拥有独立于分配给其他程序的的内存空间和系统资源（包括端口权限）。进程总是包含至少一个线程（即主线程）和任意数量的额外线程。</li>
<li>递归锁(recursive lock)<br/>
可以被同一线程多次锁住的锁。</li>
<li>信号量(semaphore)<br/>
一个受保护的变量，它限制共享资源的访问。互斥锁(mutexes)和条件(conditions)都是不同类型的信号量。</li>
<li>任务(task)<br/>
要执行的工作数量。尽管一些技术(最显著的是Carbon 多进程服务—Carbon Multiprocessing Services)使用该术语的意义有时不同，但是最通用的用法是表明需要执行的工作数量的抽象概念。</li>
<li>线程(thread)<br/>
进程里面的一个执行过程流。每个线程都有它自己的栈空间，但除此之外同一进程的其他线程共享内存。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JSPatch的一些使用注意点]]></title>
    <link href="http://www.chaisong.xyz/15378876732563.html"/>
    <updated>2018-09-25T23:01:13+08:00</updated>
    <id>http://www.chaisong.xyz/15378876732563.html</id>
    <content type="html"><![CDATA[
<p>JSPatch代码量不大，满满的都是神机妙算，到处都是黑科技。</p>

<h2 id="toc_0">主要的坑 -- UIWebView相关</h2>

<p>如果在JSPatch的代码使用前，app没有初始化过UIWebView，那会造成UIWebView中JS不能解析的问题，打开网页根本不能看。解决方案：</p>

<!--more-->

<pre><code class="language-text">JSPatch使用前先alloc一个UIWebView，然后让ARC自动dealloc它就好了：

UIWebView *webView = [[UIWebView alloc]init];   //Useless. Just to load the UIWebview framework.
webView.frame = CGRectZero;

[JPEngine startEngine];

[self startCache:^(NSString * script) {
    [JPEngine evaluateScript:script];
}]; 
</code></pre>

<p>哪怕初始化过UIWebView，也不能在使用JSPatch代码的时候进行UIWebView的初始化（既不能相同runloop初始化UIWebView），否则会造成WebView不稳定，极容易crash：</p>

<pre><code class="language-text">JavaScriptCore  WTF::equal(WTF::StringImpl const*, unsigned char const*) + 116
JavaScriptCore  std::__1::pair&lt;std::__1::pair&lt;WTF::StringImpl**, bool&gt;, unsigned int&gt; WTF::HashTable&lt;WTF::StringImpl*, WTF::StringImpl*, WTF::IdentityExtractor, WTF::StringHash, WTF::HashTraits&lt;WTF::StringImpl*&gt;, WTF::HashTraits&lt;WTF::StringImpl*&gt; &gt;::fullLookupForWriting&lt;WTF::HashSetTranslatorAdapter&lt;WTF::CStringTranslator&gt;, unsigned char const*&gt;(unsigned char const* const&amp;) + 268
JavaScriptCore  WTF::HashTableAddResult&lt;WTF::HashTableIterator&lt;WTF::StringImpl*, WTF::StringImpl*, WTF::IdentityExtractor, WTF::StringHash, WTF::HashTraits&lt;WTF::StringImpl*&gt;, WTF::HashTraits&lt;WTF::StringImpl*&gt; &gt; &gt; WTF::HashTable&lt;WTF::StringImpl*, WTF::StringImpl*, WTF::IdentityExtractor, WTF::StringHash, WTF::HashTraits&lt;WTF::StringImpl*&gt;, WTF::HashTraits&lt;WTF::StringImpl*&gt; &gt;::addPassingHashCode&lt;WTF::HashSetTranslatorAdapter&lt;WTF::CStringTranslator&gt;, unsigned char const* const&amp;, unsigned char const* const&amp;&gt;(unsigned char const* const&amp;&amp;&amp;, unsigned char const* const&amp;&amp;&amp;) + 200
JavaScriptCore  WTF::AtomicStringImpl::add(unsigned char const*) + 160
WebCore WebCore::Settings::initializeDefaultFontFamilies() + 720
WebCore WebCore::Settings::Settings(WebCore::Page*) + 484
WebCore WebCore::Settings::create(WebCore::Page*) + 36
WebCore WebCore::Page::Page(WebCore::PageConfiguration&amp;&amp;) + 184
WebKitLegacy    -[WebView(WebPrivate) _commonInitializationWithFrameName:groupName:] + 1712
WebKitLegacy    -[WebView(WebPrivate) _initWithFrame:frameName:groupName:] + 132
UIKit   -[UIWebDocumentView initWithWebView:frame:] + 332
UIKit   -[UIWebBrowserView initWithWebView:frame:] + 48
UIKit   -[UIWebBrowserView initWithFrame:] + 44
UIKit   -[UIWebView _webViewCommonInitWithWebView:scalesPageToFit:] + 244
UIKit   -[UIWebView initWithFrame:] + 76
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RN学习5——QDaily iOS app中通信和热修复实践]]></title>
    <link href="http://www.chaisong.xyz/15378876732597.html"/>
    <updated>2018-09-25T23:01:13+08:00</updated>
    <id>http://www.chaisong.xyz/15378876732597.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>因为我们还用React Native 0.30版本，以后肯定会换最新版本，所以着急炒炒这份冷饭，总结总结使用经验。</p>

<p><a href="http://www.chaisong.xyz/2016/11/23/2016-11-23/">上一篇</a>介绍了Android的一些React Native应用中Native部分的开发，这篇主要在这个基础上继续介绍下iOS部分。iOS坑会少一点。</p>

<p>该文章为系列文章，之前的文章为<a href="http://www.chaisong.xyz/2016/06/20/RN%E5%AD%A6%E4%B9%A01%E2%80%94%E2%80%94%E5%89%8D%E5%A5%8F%EF%BC%8Capp%E6%8F%92%E4%BB%B6%E5%8C%96%E5%92%8C%E7%83%AD%E6%9B%B4%E6%96%B0%E7%9A%84%E6%8E%A2%E7%B4%A2/">RN学习1——前奏，app插件化和热更新的探索</a>，<a href="http://www.chaisong.xyz/2016/06/22/RN%E5%AD%A6%E4%B9%A02%E2%80%94%E2%80%94%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/">RN学习2——客户端开发者的一些准备工作</a>，<a href="http://www.chaisong.xyz/2016/08/02/RN%E5%AD%A6%E4%B9%A03%E2%80%94%E2%80%94%E9%9B%86%E6%88%90%E8%BF%9B%E5%B7%B2%E6%9C%89%E5%8E%9F%E7%94%9F%E9%A1%B9%E7%9B%AE/">RN学习3——集成进现有原生项目</a>，<a href="http://www.chaisong.xyz/2016/11/23/2016-11-23/">RN学习4——QDaily Android app中通信和热修复实践</a>。</p>
</blockquote>

<h2 id="toc_0">一、先说针对hot fix的支持</h2>

<h3 id="toc_1">启动时请求JSBundle更新</h3>

<p>直接看流程图，此类用来管理JSBundle的位置以及热更新的版本。</p>

<p><img src="http://obp30zydr.bkt.clouddn.com/RNBundleSync.jpg" alt=""/><br/>
<!--more--></p>

<h3 id="toc_2">资源文件的指向</h3>

<p>上一篇说过，为支持资源的热更新，我们将所有resource都使用<code>http://qdaily.cage/</code>开头作为标记，在编译Android的JSBundle过程中，将其修改为file://data/*的本地文件路径。</p>

<p>iOS在此处的处理更为简单：在看React Native源码中可以发现，处理ImageView（即RCTImageView）的请求资源的方法在RCTConvert中，负责将传入的source json文件进行识别，如果uri以http开头，最终会调到<code>+ (NSURL *)NSURL:(id)json</code>方法中，最后调用系统方法<code>NSURL *URL = [NSURL URLWithString:path]</code>完成地址的绑定。知道原理就好了，我们只需要改变系统的<code>+(NSURL*) URLWithString:(NSString*)url</code>方法即可：</p>

<pre><code class="language-objectivec">// NSURL+QDAdditions.m

+ (void) load {
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
        [self swizzleSEL:@selector(URLWithString:) withSEL:@selector(swizzled_URLWithString:)];
    });
}

+ (void)swizzleSEL:(SEL)originalSEL withSEL:(SEL)swizzledSEL {
    Class class = object_getClass((id)self); //不是类方法这里写 Class class = [self class];  就好了
    Method originalMethod = class_getInstanceMethod(class, originalSEL);
    Method swizzledMethod = class_getInstanceMethod(class, swizzledSEL);
    
    BOOL didAddMethod =
    class_addMethod(class,
                    originalSEL,
                    method_getImplementation(swizzledMethod),
                    method_getTypeEncoding(swizzledMethod));
    
    if (didAddMethod) {
        class_replaceMethod(class,
                            swizzledSEL,
                            method_getImplementation(originalMethod),
                            method_getTypeEncoding(originalMethod));
    } else {
        method_exchangeImplementations(originalMethod, swizzledMethod);
    }
}

+ (NSURL* )swizzled_URLWithString:(NSString*)strUrl {
    if ([strUrl hasPrefix:RNBundleResourcePrefix]) {
        strUrl = [GET_SERVICE(QDRNBundleManager) fileURLStringFromRNResourceRequest:strUrl];
    }
   return [self swizzled_URLWithString:strUrl];
}
</code></pre>

<p>原理很简单，替换NSURL的类方法，针对固定Prefix的url进行处理，下面是处理方法，针对模拟器情况下，为调试方便，会指向本地server的地址，非模拟器情况会按顺序读取沙盒和mainBundle。</p>

<pre><code class="language-objectivec">//非模拟器读缓存
- (NSString *)fileURLStringFromRNResourceRequest:(NSString *)request {
#if (TARGET_IPHONE_SIMULATOR)
    return [request stringByReplacingOccurrencesOfString:RNBundleResourcePrefix withString:@&quot;http://localhost:8081/resources/&quot;];
#else
    NSString* strPath = [request stringByReplacingOccurrencesOfString:RNBundleResourcePrefix withString:@&quot;&quot;];
    
    //查找沙盒
    if (_isDirReady) {
        NSString* file = [_sandBoxBundleResourceDirectory stringByAppendingPathComponent:strPath];
        if ([_fileManager fileExistsAtPath:file]) {
            return [NSString stringWithFormat:@&quot;file://%@&quot;, file];
        }
    }
    //查找bundle
    NSString* file = [[NSBundle mainBundle].resourcePath stringByAppendingPathComponent:strPath];
    if ([_fileManager fileExistsAtPath:file]) {
        return [NSString stringWithFormat:@&quot;file://%@&quot;, file];
    }
    
    return request;
#endif
}

</code></pre>

<h2 id="toc_3">二、调起一个React Native组件</h2>

<p>这里appdelegate中增加RCTBridge的成员变量bridge，因其初始化时会进行bundle的load操作以及大量的反射来生成module映射表，耗性能还耗内存，而我们又是混合app，很大概率不会使用，所以采用懒加载方式。为调试方便，在模拟器下指向本机server。</p>

<pre><code class="language-objectivec">- (RCTBridge*)bridge {
    if (_bridge == nil) {
        _bridge= [[RCTBridge alloc]initWithDelegate:self launchOptions:nil];
    }
    return _bridge;
}

#pragma - mark RCTBridgeDelegate
- (NSURL*) sourceURLForBridge:(RCTBridge *)bridge {
#if (TARGET_IPHONE_SIMULATOR)
    return [NSURL URLWithString:@&quot;http://localhost:8081/index.ios.bundle?platform=ios&amp;dev=true&quot;];
#else
    return [NSURL fileURLWithPath:GET_SERVICE(QDRNBundleManager).localReactNativeBundle];
#endif
}
</code></pre>

<p>在使用过程中，iOS没有那么多坑，很简单，初始化rootView并赋给ViewController的self.view就好了，传参可以传字典，所有基本数据类型都可以~</p>

<pre><code class="language-objectivec">- (void) showImageSplash:(QDSplashResource*) source :(QDSplashEntity *)splash{
    RCTRootView *rootView = [[RCTRootView alloc] initWithBridge:[AppDelegate sharedAppDelegate].bridge
                                                     moduleName:@&quot;adImageLaunch&quot;
                                              initialProperties:@{
                                                                  @&quot;imagePaths&quot; : source.imagePathArray,
                                                                  @&quot;redirectUrl&quot; : splash.url,
                                                                  @&quot;feedbackUrl&quot; : splash.feedbackUrl,
                                                                  @&quot;adTagUrl&quot; : splash.adTagUrl,
                                                                  @&quot;totalSeconds&quot; : splash.totalSeconds,
                                                                  @&quot;extras&quot; : source.themeDictionary? source.themeDictionary: @{}
                                                                  }];
    [self showAdWithRN:rootView];
}

- (void) showAdWithRN:(RCTRootView* )rootView {
    if (rootView == nil) {
        return;
    }
    
    QDLaunchAdViewController* adControl = [[QDLaunchAdViewController alloc] init];
    
    rootView.frame = [UIScreen mainScreen].bounds;
    UIView *adVideoHub = [[[NSBundle mainBundle] loadNibNamed:@&quot;LaunchVideoHub&quot; owner:nil options:nil] firstObject];
    adVideoHub.frame = [UIScreen mainScreen].bounds;
    
    rootView.loadingView = adVideoHub;
    adControl.view = rootView;
    _currentAdController = adControl;
    adControl.delegate = self;
    
    self.adWindow.rootViewController = [[QDNavigationController alloc] initWithRootViewController: adControl];
}
</code></pre>

<p>非常小的一个技巧，可以把任意一个xib文件座位RCTRootView的loadingView，作为其没有加载时候的默认图。</p>

<h2 id="toc_4">三、JS端向Native端的通信方式</h2>

<p>先贴一段code，和之前Android部分贴的功能一致：</p>

<pre><code class="language-objectivec">@interface LaunchBridgeModule : NSObject&lt;RCTBridgeModule&gt;

@end


@implementation LaunchBridgeModule

RCT_EXPORT_MODULE();

RCT_EXPORT_METHOD(dismissSplash:(RCTResponseSenderBlock)callback)
{
    [[QDLaunchADTool shareLaunchTool] clickForRemoveLaunthADView];
    callback(@[[NSNull null]]);
}

RCT_EXPORT_METHOD(open:(NSString*) strUrl:(RCTResponseSenderBlock)callback)
{
    if (EmptyString(strUrl)) {
        return;
    }
    QDLaunchAdViewController* launchController = [QDLaunchADTool shareLaunchTool].currentAdController;
    if (launchController) {
        strUrl = [strUrl stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];
        [QDViewControllerRouter routeWithURL:[NSURL URLWithString:strUrl] byNavigationController:launchController.navigationController ArticleDetailJumpDelegate:nil];
        launchController.view.window.windowLevel = UIWindowLevelNormal;
        launchController.showRedirectURL = YES;
    }
    callback(@[[NSNull null]]);
}

- (dispatch_queue_t)methodQueue
{
    return dispatch_get_main_queue();
}
@end
</code></pre>

<p>所有JS能调用的Native都能力都在<code>RCTBridgeModule</code>这个protocol里面做了定义。每个原生模块都以单实例模式限制了嵌入。</p>

<p><code>RCTBridgeModule</code>这个协议只有一个require方法：</p>

<pre><code class="language-text">+ (NSString *)moduleName;
// 对应Android中：
public String getName();
</code></pre>

<p>相对于Android将Module加进react native的映射表要先后生成Packager文件，然后addPackage两步，iOS拥有<code>宏</code>和<code>load</code>方法：在implement中增加<code>RCT_EXPORT_MODULE();</code>一行宏就能解决之前的所有问题，极限解耦。该宏会覆写require方法，默认返回nil，并覆写load方法，该方法会在app启动时候class进入内存就会调用。具体load方法有哪些黑科技请自行google，这里不做介绍。</p>

<p>通过load方法的覆写，会把当前class在ReactBridge中进行注册，如果moduleName为空就直接使用当前class的name（注意，不管是否为空，都要保证最终module name和Android中定义的一致）。</p>

<p>第二个神奇的黑科技是<code>RCT_EXPORT_METHOD()</code>这个宏（Android中一般实现AOP编程--所谓黑科技基本用注解，iOS基本是宏）。这个宏会为其包住的方法再生成一个新的方法：</p>

<pre><code class="language-text">+ (NSArray&lt;NSString *&gt; *)RCT_CONCAT(__rct_export__, \
    RCT_CONCAT(js_name, RCT_CONCAT(__LINE__, __COUNTER__))) { \
    return @[@#js_name, @#method]; \
}
</code></pre>

<p>看实现可以知道所有用这个宏新生成的方法都以<code>__rct_export__</code>开头，返回值的都包含其方法名，在bridge初始化的时候，通过OC的runtime特性将其添加进入映射表，从而实现了&quot;export&quot;。</p>

<pre><code class="language-objectivec"> while (cls &amp;&amp; cls != [NSObject class] &amp;&amp; cls != [NSProxy class]) {
      Method *methods = class_copyMethodList(object_getClass(cls), &amp;methodCount);

      for (unsigned int i = 0; i &lt; methodCount; i++) {
        Method method = methods[i];
        SEL selector = method_getName(method);
        if ([NSStringFromSelector(selector) hasPrefix:@&quot;__rct_export__&quot;]) {
          IMP imp = method_getImplementation(method);
          NSArray&lt;NSString *&gt; *entries =
            ((NSArray&lt;NSString *&gt; *(*)(id, SEL))imp)(_moduleClass, selector);
          id&lt;RCTBridgeMethod&gt; moduleMethod =
            [[RCTModuleMethod alloc] initWithMethodSignature:entries[1]
                                                JSMethodName:entries[0]
                                                 moduleClass:_moduleClass];

          [moduleMethods addObject:moduleMethod];
        }
      }

      free(methods);
      cls = class_getSuperclass(cls);
    }
</code></pre>

<p>这些非常好的宏技巧我也在我自己的<a href="https://github.com/droison/iOSBus">iOSBus</a>中进行了广泛的使用，实现了非常好的解耦，还在进行开发调试中，欢迎follow、star。</p>

<p><code>RCTBridgeModule</code>中还定义了一些optional方法，我这里只用了一个methodQueue，规定调用在主线程队列，这个也是默认队列，可以不写，其它请自行发现。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RN学习4——QDaily Android app中通信和热修复实践]]></title>
    <link href="http://www.chaisong.xyz/15378876732633.html"/>
    <updated>2018-09-25T23:01:13+08:00</updated>
    <id>http://www.chaisong.xyz/15378876732633.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>React Native现在已经到了0.37版本了，在集成RN初期使用的0.30版本还不支持将resources打入bundle实施热更新，0.37版本已经解决了这些问题，如果再不写篇文章，炒炒这份冷饭，那就过气了。</p>

<p>QDaily现在在Android和iOS的版本中都集成了React Native，用其做广告效果页的展示。</p>

<p>本文介绍基于Android平台，在RN进行混合app研发过程中，native部分做过的一些工作和踩过一些坑。</p>

<p>本该双平台一起介绍的，但Android的坑多，先说Android，iOS的对应工作会在<a href="http://www.chaisong.xyz/2016/11/23/2016-11-25/">下个文章</a>描述。</p>

<p>该文章为系列文章，之前的文章为<a href="http://www.chaisong.xyz/2016/06/20/RN%E5%AD%A6%E4%B9%A01%E2%80%94%E2%80%94%E5%89%8D%E5%A5%8F%EF%BC%8Capp%E6%8F%92%E4%BB%B6%E5%8C%96%E5%92%8C%E7%83%AD%E6%9B%B4%E6%96%B0%E7%9A%84%E6%8E%A2%E7%B4%A2/">RN学习1——前奏，app插件化和热更新的探索</a>，<a href="http://www.chaisong.xyz/2016/06/22/RN%E5%AD%A6%E4%B9%A02%E2%80%94%E2%80%94%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/">RN学习2——客户端开发者的一些准备工作</a>，<a href="http://www.chaisong.xyz/2016/08/02/RN%E5%AD%A6%E4%B9%A03%E2%80%94%E2%80%94%E9%9B%86%E6%88%90%E8%BF%9B%E5%B7%B2%E6%9C%89%E5%8E%9F%E7%94%9F%E9%A1%B9%E7%9B%AE/">RN学习3——集成进现有原生项目</a>。</p>
</blockquote>

<h2 id="toc_0">一、Android中RN的View初始化及传参</h2>

<h3 id="toc_1">马上看代码</h3>

<pre><code class="language-java">//React相关组件初始化
ReactRootView mReactRootView = new ReactRootView(this);
mReactInstanceManager = ReactInstanceManager.builder()
      .setApplication(getApplication())
      .setJSBundleFile(getBundleFilePath())
      .setJSMainModuleName(&quot;index.android&quot;)
      .addPackage(new MainReactPackage())
      .setUseDeveloperSupport(BuildConfig.DEBUG)
      .setInitialLifecycleState(LifecycleState.BEFORE_RESUME)
      .setUseOldBridge(true)
      .build();

//准备参数
Bundle bundle = new Bundle();
bundle.putString(&quot;url&quot;, &quot;http://www.qdaily.com&quot;);
bundle.putFloat(&quot;totalSeconds&quot;, 12);
bundle.putInt(&quot;style&quot;, 1);
bundle.putString(&quot;extras&quot;, &quot;{\&quot;key\&quot; : \&quot;value\&quot;}&quot;);
bundle.putStringArray(&quot;imagePaths&quot;, new String[]{&quot;url1&quot;, &quot;url1&quot;});

//组件启动
mReactRootView.startReactApplication(mReactInstanceManager, &quot;adImageLaunch&quot;, bundle);
</code></pre>

<span id="more"></span><!-- more -->

<h3 id="toc_2">先解释下方法名和对应的参数</h3>

<ul>
<li>上面的<code>getBundleFilePath()</code>可以指向本地路径，assert://开头或者file://开头，如果是测试情况，也可以以http://开头，最终对应一个JSBundle文件。</li>
<li>&quot;index.android&quot;为MainModule的名字，相当于当前JSBundle的程序入口。</li>
<li>addPackage()用来增加支持的package，基本意思就是用于js端调用的native部分，包含函数和原生自定义组件。</li>
<li>setUseOldBridge(true) 在当前版本需要设定，否则会报错，应该是用于兼容旧版本使用。最新版本（0.37）还没测试</li>
<li>&quot;adImageLaunch&quot;意思是该view对应的bundle中的对应component，该component会生命在JSBundle的MainModule（当前为&quot;index.android&quot;）中声名。</li>
</ul>

<h3 id="toc_3">再重点说下支持的传参（android.os.Bundle）。因为同名，为消除歧义，Bundle特指Android中的android.os.Bundle，React Native中的Bundle用JSBundle命名。</h3>

<p>RN的传参仅支持这一种方式（文件、网络自行读取不算），但也不是Bundle支持的全部支持，具体参见Arguments.java源码，它将Bundle转换成为WritableMap组件（类json数据结构）。查看源码可知：</p>

<blockquote>
<p>仅支持通过Bundle传递<code>Number</code>（int、float、double等基本数据类型）、<code>String</code>、<code>Boolean</code>、或者包含以上类型的<code>数组</code>数据、或者包含以上类型的<code>Bundle</code>数据。</p>

<p>其它无论是否支持Parcelable、Serializable，或List都会在传输过程中收到IllegalArgumentException异常。</p>

<p>此处仅仅Android如此，iOS可以直接传输NSDictionary，系统级转换成JSON数据格式。</p>
</blockquote>

<p><u>如果传输（透传）复杂数据类型，请自行转成JSON用字符串用String传输，ReactNative端用<code>JSON.parse()</code>进行转换</u></p>

<h2 id="toc_4">二、UI集成</h2>

<p>此处集成可以分为Activity继承和fragment集成，以及View的集成（未测试）<br/>
参考这里<a href="http://www.voidcn.com/blog/chichengjunma/article/p-6293726.html">http://www.voidcn.com/blog/chichengjunma/article/p-6293726.html</a>，貌似会再集成过程中有问题。</p>

<h3 id="toc_5">Activity集成</h3>

<p>在<code>onCreate</code>方法中，调用<code>setContentView(mReactRootView);</code>，直接将上面生成的ReactRootView赋给Activity的ContentView。</p>

<p>Activity需要 implements DefaultHardwareBackBtnHandler 接口，用于处理返回按键。</p>

<p>同时在生命周期的template方法中透传生命周期给ReactInstanceManager：</p>

<pre><code class="language-text"> @Override
    protected void onPause() {
        super.onPause();

        if (mReactInstanceManager != null) {
            mReactInstanceManager.onHostPause();
        }
    }

    @Override
    protected void onResume() {
        super.onResume();

        if (mReactInstanceManager != null) {
            mReactInstanceManager.onHostResume(this, this);
        }
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        mReactInstanceManager.destroy();
    }

    @Override
    public void onBackPressed() {
        if (mReactInstanceManager != null) {
            mReactInstanceManager.onBackPressed();
        } else {
            super.onBackPressed();
        }
    }
</code></pre>

<h3 id="toc_6">Fragment集成</h3>

<p>和Activity集成相似，不过需要在onCreateView中返回上文的mReactRootView。生命周期自行处理。</p>

<h3 id="toc_7">View的集成（不推荐）</h3>

<p>此处没做测试，感觉在处理生命周期会有问题，仅仅提供方法，欢迎交流</p>

<pre><code class="language-java">mNativeView = (FrameLayout) findViewById(R.id.nativeView);//原生布局中的view
//上文 mReactRootView 的初始化
mNativeView.addView(mReactRootView);//添加react布局
</code></pre>

<h2 id="toc_8">三、Native部分被调用的Module实现</h2>

<blockquote>
<p>说的太拗口了，其实就是React端调用原生方法时候，java部分需要做的一些工作，参见<a href="http://reactnative.cn/docs/0.30/native-modules-android.html">原生模块</a></p>
</blockquote>

<h3 id="toc_9">1、定义JavaModule</h3>

<p>官方文档其实很清楚了，我这里简单说下我们这边的使用情况：</p>

<pre><code class="language-java">public class LaunchBridgeModule extends ReactContextBaseJavaModule {

    public LaunchBridgeModule(ReactApplicationContext reactContext) {
        super(reactContext);
    }

    @ReactMethod
    public void dismissSplash(Callback errorCallback) {
        Activity activity = MManagerCenter.getManager(ActivityController.class).getTopActivity();
        if (activity != null) {
            activity.finish();
        }
        errorCallback.invoke(&quot;&quot;);
    }

    @ReactMethod
    public void open(String url, Callback errorCallback) {
        Activity activity = MManagerCenter.getManager(ActivityController.class).getTopActivity();
        if (activity != null) {
            activity.setResult(Activity.RESULT_OK, new Intent().setData(Uri.parse(url)));
            activity.finish();
        }
        errorCallback.invoke(&quot;&quot;);
    }

    @Override
    public String getName() {
        return &quot;LaunchBridgeModule&quot;;
    }

    @Override
    public Map&lt;String, Object&gt; getConstants() {
        final Map&lt;String, Object&gt; constants =  new HashMap&lt;&gt;();
        constants.put(&quot;STATUS_BAR_HEIGHT&quot;, LocalDisplay.STATUS_BAR_HEIGHT_DP);
        constants.put(&quot;SCREEN_HEIGHT&quot;, LocalDisplay.SCREEN_HEIGHT_DP);
        constants.put(&quot;SCREEN_WIDTH&quot;, LocalDisplay.SCREEN_WIDTH_DP);
        constants.put(&quot;NAVIGATION_BAR_HEIGHT&quot;, LocalDisplay.NAVIGATION_BAR_HEIGHT_DP);
        return constants;
    }
}
</code></pre>

<p>此处我们暴露了3个方法给JS端，分别为关闭页面、跳转页面和获取常量3个，其中前两个方法为异步方法，最后一个是同步方法。</p>

<p>异步方法用<code>@ReactMethod</code>注解标记，可以随便自定义方法名，所有被标记的方法会再addPackage后通过反射放在一个映射表中，一个类型的Module在同一ReactInstanceManager中只有一个对象。</p>

<p>同步方法在父类接口里面定义，默认返回null。之所以是同步方法，是因为在ReactInstanceManager时就进行了调用，将返回值封成了固定格式的String给了ReactBridge中，该bridge为配置表，JS端直接有这个表，因此能同步执行，但也存在问题，就是不能运行时动态使用，只能进行常量初始化（名字干脆就叫getConstants......）。方法调用堆栈如下：</p>

<p><img src="http://blog-10057491.file.myqcloud.com/RNConstantsStack.jpg" alt=""/></p>

<p>getName()方法用于JS端调用时候使用的名字（不是类名），请不要重复！</p>

<p>一个注意点：<code>请相同作用的Module在Android和iOS部分getName，getConstants，以及所有异步方法名称完全一致，异步方法的入餐类型完全一致</code>。否则JS端调取原生方法时候还需要判断平台。</p>

<h3 id="toc_10">2、定义ReactPackage</h3>

<p>所有Native部分的定义的方法以及View组件，最终都要用自定义的ReactPackage进行包装，来告诉ReactBridge，bridge用映射表供JS使用。</p>

<pre><code class="language-java">public class LaunchReactPackage implements ReactPackage {
    @Override
    public List&lt;Class&lt;? extends JavaScriptModule&gt;&gt; createJSModules() {
        return Collections.emptyList();
    }

    @Override
    public List&lt;ViewManager&gt; createViewManagers(ReactApplicationContext reactContext) {
        return Collections.emptyList();
    }

    @Override
    public List&lt;NativeModule&gt; createNativeModules(
            ReactApplicationContext reactContext) {
        List&lt;NativeModule&gt; modules = new ArrayList&lt;&gt;();
        modules.add(new LaunchBridgeModule(reactContext));
        return modules;
    }
}
</code></pre>

<p>我们这里没有自定义UI组件（比较复杂，如果自定义还要有JS部分和iOS部分的开发）。ReactPackage中定义的三个方法：</p>

<ul>
<li><code>createViewManagers</code> 为JS端可以使用的自定义Native View。</li>
<li><code>createNativeModules</code> 为可使用的方法，我们只用了这里。</li>
<li><code>createJSModules</code> 没使用过，也没在0.30的代码中看到实现，先忽略。</li>
</ul>

<p>之后只要在需要使用自定义View或者方法的ReactRootView的ReactInstanceManager的初始化时，将响应的package add进去即可。</p>

<h2 id="toc_11">四、0.30版本下的Android热修复实现</h2>

<p>JSBundle的更新为在app启动之后会向后台sync RN的最新JSBundle，如果server有新的且本地不存在，则下载，否则什么也不做。逻辑很简单，不做介绍了。</p>

<p>这里主要介绍资源的热更新。JS部分默认支持的协议包括<code>assert://</code>、<code>file://</code>以及<code>http://</code>协议，一些资源icon采用http协议肯定是不合适的（那也就没有热更新的必要了），assert是打在app包里的，Android的热更新肯定是file协议了，具体实现分为两个部分：</p>

<h3 id="toc_12">1、java部分将资源从assert copy到data下的固定文件夹中</h3>

<pre><code class="language-java">private void copyFileOrDir(String path) {
   AssetManager assetManager = mContext.getAssets();
   String assets[] = null;
   try {
       assets = assetManager.list(path);
       if (assets.length == 0) {
           copyFile(path);
       } else {
           File dir = new File(mContext.getFilesDir(), path);
           if (!dir.exists())
               dir.mkdir();
           for (int i = 0; i &lt; assets.length; ++i) {
               copyFileOrDir(path + &quot;/&quot; + assets[i]);
           }
       }
   } catch (IOException ex) {
       QLog.e(&quot;tag&quot;, &quot;I/O Exception&quot;, ex);
   }
}

private void copyFile(String filename) {
   AssetManager assetManager = mContext.getAssets();

   InputStream in = null;
   OutputStream out = null;
   try {
       in = assetManager.open(filename);
       out = new FileOutputStream(new File(mContext.getFilesDir(), filename));

       byte[] buffer = new byte[1024];
       int read;
       while ((read = in.read(buffer)) != -1) {
           out.write(buffer, 0, read);
       }
       in.close();
       in = null;
       out.flush();
       out.close();
       out = null;
   } catch (Exception e) {
       QLog.e(TAG, e.getMessage());
   }

}
</code></pre>

<p>这样热更新只需要将资源覆盖到对应的文件夹中进行处理即可。此处Native部分很简单，关键是JS部分操作，因为按照写法，资源路径应该是file:///data/data/packagename/file/*，显然iOS部分不能正常读取，下面介绍JS部分。</p>

<h3 id="toc_13">2、JS部分操作需要在JSBundle动态替换资源路径</h3>

<blockquote>
<p>此处的规范比较严格，资源需要放在固定路径中，资源请求需要用严格的cage协议</p>
</blockquote>

<h5 id="toc_14">（1）固定资源存放位置</h5>

<p>首先请将所有资源文件（主要是image）放在根目录的resources下，不允许有嵌套文件夹；</p>

<h5 id="toc_15">（2）固定js中资源访问方式</h5>

<p>将所有js代码中请求的本地资源代码由 <code>require(&#39;./xxx.png&#39;)</code> 改为<code>{uri:&#39;http://qdaily.cage/xxx.png&#39;}</code>。其中xxx.png为<code>上一条</code>中提到的resources目录下的同名资源：</p>

<pre><code class="language-javascript">   &lt;Image source={require(&#39;./cancel.png&#39;)&gt;
   改为
   &lt;Image source={{uri:&#39;http://qdaily.cage/cancel.png&#39;}}&gt;
</code></pre>

<h5 id="toc_16">（3）修改0.30中react-native的js源码</h5>

<ul>
<li>1、node_modules/react-native/Libraries/Image/image.android.js</li>
</ul>

<pre><code class="language-javascript">render: function() {
  ...
  ...
  
  //else后的代码块为新增
  if (source &amp;&amp; source.uri === &#39;&#39;) {
    console.warn(&#39;source.uri should not be an empty string&#39;);
  } else {
    var prefix = &#39;http://qdaily.cage/&#39;;
    var match = source.uri.indexOf(prefix);
    if (match == 0) { //qdaily.cage://开头  
      console.log(__DEV__);
      var realUrl = source.uri.substring(prefix.length, source.uri.length);
      if (__DEV__) { //debug 情况  RN 服务器 
        source.uri = resolveAssetSource.getDevServerURL() + &#39;react/resources/&#39; + realUrl;
      } else { //release 情况
        source.uri = &#39;file://&#39; + &#39;/data/data/com.qdaily.ui/files/rnimgs/&#39; + realUrl;
      }
    }
  }
  
  ...
  ...
}
</code></pre>

<ul>
<li>2、node_modules/react-native/Libraries/Image/resolveAssetSource.js<br/>
在文件结尾处增加：</li>
</ul>

<pre><code class="language-javascript">module.exports.getDevServerURL = getDevServerURL;
</code></pre>

<p>在这一部分，我自己写了一个0.30情况下的shell脚本，在npm install之后运行脚本替换即可。可以点击这个<a href="http://blog-10057491.file.myqcloud.com/0.30RN-AndroidPreBuildShell.zip">链接</a>进行下载。</p>

<p>下一篇文章会介绍iOS部分针对热修复在Native部分需要做的工作。</p>

]]></content>
  </entry>
  
</feed>
